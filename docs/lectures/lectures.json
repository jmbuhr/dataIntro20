[
  {
    "path": "lectures/lecture4/",
    "title": "Lecture 4",
    "description": "... which is all about functions, bringing the whole tidyverse together and\nexploring advanced dplyr data wrangling techniques.",
    "author": [
      {
        "name": "Jannik Buhr",
        "url": "https://jmbuhr.de"
      }
    ],
    "date": "2020-11-22",
    "categories": [
      "lecture"
    ],
    "contents": "\n\nContents\nVideo\nSlides\nScript\nMotivation\nIteration\nFunctional Programming\nThe Imperative Programming Approach\n\n“If you copy and paste the same code more than three times, write a function.”\nNoticing a Pattern\nWhere to put your Functions\n\nMany Models\nAdvanced dplyr\n\nExercises\nThe whole Deal\nRoman emperors\nDairy Products in the US\n\n\nResources\n\nVideo\nWatch today’s video here:\n\n\nSlides\nHover over the slides and press f for full screen. Press ? for a list of keyboard shortcuts.\n\n\nknitr::include_url(\"slides4.html\")\n\n\n\n\n\nScript\nMotivation\nMy goal today is to bring together everything we learned so far and solidify our understanding of wrangling data in the tidyverse. If all goes according to plan, we will then have more mental capacity freed up for the statistics starting next week. And our understanding of data will hopefully enable us to experiment and play with statistical concepts without getting stuck too much on data wrangling. This also means that today’s lecture might be the most challenging so far, because everything learned up until now will – in one way or another – be relevant.\nAs you might be able to tell, mental models are one of my favorite topics. We are starting today with a powerful mental model teased at last week. I am talking about iteration.\nIteration\nIteration is the basic idea of doing one thing multiple times. This is an area where computers shine, so in this chapter we will learn to fully utilize the power at our fingertips.\nWe had our first encounter with iteration in a very implicit form. When we use R’s basic math operators, the computer is iterating behind the scenes. Take this expression:\n\n\n1:3 + 1:3\n\n\n[1] 2 4 6\n\nThis operation is vectorized. Without us having to tell R to do so, R will add the first element of the first vector to the first element of the second vector and so forth.\nNotice, how it looks like the operation happens all at the same time. But in reality, this is not what happens. The computer is just really fast at adding numbers, one after the other.\nThe mathematical operations in R call another programming language that does the actual addition. This other programming language is closer to the way computers think, making it less fun to write for us humans, but also faster because the instructions are easier to translate into actions for our computer processor.\nWhen we find a task that we want to apply to multiple things, and this task is not already vectorized, we need to make our own iteration. There are actually two schools of though on how to talk about iteration and consequently, how to write it in code.\nI will use a realworld example to illustrate this: Reading in Multiple Files\nFunctional Programming\nRemember the gapminder dataset? Well, we are working with it again, but this time, our collaborator sent us one csv-file for each continent. As usual, we load the tidyverse first. For the script I also load the rmarkdown package and the knitr package to have more control over printing tables.\n\n\nlibrary(tidyverse)\nlibrary(rmarkdown)\nlibrary(knitr)\n\n\n\nWe already know how to read in one csv-file:\n\n\n# n_max = 3 is just here for the script\nread_csv(\"data/Africa.csv\", n_max = 3)\n\n\n# A tibble: 3 x 5\n  country  year lifeExp      pop gdpPercap\n  <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n1 Algeria  1952    43.1  9279525     2449.\n2 Algeria  1957    45.7 10270856     3014.\n3 Algeria  1962    48.3 11000948     2551.\n\nWe have a function (read_csv) that takes a file path and returns (spits out) the data. In this first school of thought, the Functional Programming style, the next idea is to have a function, that takes two things: a function and a vector (atomic or list). And it feeds the individual elements of the vector to the function, one after another. In mathematics, the relation between a set of inputs and a set of outputs is called a map, which is where the name of the following family of functions comes from. In the tidyverse, these functional programming concepts live in the purrr package.\n\n\n\n\n\nFirst, we create the vector of things that we want to iterate over, the things that will be fed into our function one after the other:\n\n\npaths <- dir(\"data\", full.names = TRUE)\npaths\n\n\n[1] \"data/Africa.csv\"   \"data/Americas.csv\" \"data/Asia.csv\"    \n[4] \"data/Europe.csv\"   \"data/Oceania.csv\" \n\nNow we have 5 file paths. We can test our understanding by passing just one of them to read_csv to make sure our function works:\n\n\nread_csv(paths[[1]], n_max = 3)\n\n\n# A tibble: 3 x 5\n  country  year lifeExp      pop gdpPercap\n  <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n1 Algeria  1952    43.1  9279525     2449.\n2 Algeria  1957    45.7 10270856     3014.\n3 Algeria  1962    48.3 11000948     2551.\n\nIt is time for the map function!\n\n\nall_datasets <- map(paths, read_csv)\n\n\n\nThat’s it! We now have a list that contains all five datasets.\nBut we lost the information about which file the elements of the list came from, which is the name if the continent! We can fix this by using a named list instead of a regular list to pass to map:\n\n\nnames(paths) <- basename(paths) %>%\n  str_remove(\"\\\\.csv\")\n\nmy_data <- map(paths, read_csv)\n\n\n\nThe function str_remove is part of the stringr package in the tidyverse. It’s functions, which handle all kinds of operations on text, start with str_.\n\n\n\n\n\nAnd now we can combine them into one big dataset using bind_rows, which stacks tibbles on top of each other. The extra argument .id determines the name for the column in which we store the names of the list items.\n\n\nmy_data %>%\n  bind_rows(.id = \"continent\")\n\n\n# A tibble: 1,704 x 6\n   continent country  year lifeExp      pop gdpPercap\n   <chr>     <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n 1 Africa    Algeria  1952    43.1  9279525     2449.\n 2 Africa    Algeria  1957    45.7 10270856     3014.\n 3 Africa    Algeria  1962    48.3 11000948     2551.\n 4 Africa    Algeria  1967    51.4 12760499     3247.\n 5 Africa    Algeria  1972    54.5 14760787     4183.\n 6 Africa    Algeria  1977    58.0 17152804     4910.\n 7 Africa    Algeria  1982    61.4 20033753     5745.\n 8 Africa    Algeria  1987    65.8 23254956     5681.\n 9 Africa    Algeria  1992    67.7 26298373     5023.\n10 Africa    Algeria  1997    69.2 29072015     4797.\n# … with 1,694 more rows\n\nThere is yet another shortcut we can employ. The purrr package contains various variants of the map function. map itself will always return a list, whereas variants like map_chr always return an atomic character vector,map_dbl always returns numbers, map_lgl always return logical (yes or no, TRUE / FALSE) vectors. Combining a list into one dataframe (by rows) is so common that there is also a special map function for this: map_dfr.\n\n\ngapminder <- map_dfr(paths, read_csv, .id = \"continent\")\ngapminder\n\n\n# A tibble: 1,704 x 6\n   continent country  year lifeExp      pop gdpPercap\n   <chr>     <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n 1 Africa    Algeria  1952    43.1  9279525     2449.\n 2 Africa    Algeria  1957    45.7 10270856     3014.\n 3 Africa    Algeria  1962    48.3 11000948     2551.\n 4 Africa    Algeria  1967    51.4 12760499     3247.\n 5 Africa    Algeria  1972    54.5 14760787     4183.\n 6 Africa    Algeria  1977    58.0 17152804     4910.\n 7 Africa    Algeria  1982    61.4 20033753     5745.\n 8 Africa    Algeria  1987    65.8 23254956     5681.\n 9 Africa    Algeria  1992    67.7 26298373     5023.\n10 Africa    Algeria  1997    69.2 29072015     4797.\n# … with 1,694 more rows\n\nNow that was efficient! It only took us a couple of lines. We can even do the whole thing in one chain of functions using the pipe. But keep in mind that this is not the way we came up with it. No one expects you to come up with the shortest and most concise solution on the first go. But sometimes it can pay off to revisit your first solution that involves multiple temporary variables we don’t really need for the rest of the script and clean it up a bit. This might make it easier to come back to your code in the future and be able to read what is going on faster (because there are less lines to read).\n\n\ngapminder <-\n  dir(\"data\", full.names = TRUE) %>% \n  set_names(function(name) basename(name) %>% str_remove(\"\\\\.csv\")) %>%\n  map_dfr(read_csv, .id = \"continent\")\n\n\n\nI want to take a moment to introduce yet another shortcut we can take. Notice, how in set_names I created a function to process the names without giving it a name. This is called an anonymous function. Sometimes people also call it a lambda function, because it originates from something called lambda calculus. Because the tilde symbol ~ is the closest we get to \\(\\lambda\\) on an English keyboard, this is used to create anonymous functions on the fly. The don’t even have to worry about names for our arguments, it automatically creates a function where the argument is named “.x” (and “.y” if you need multiple arguments). See the documentation of map, especially the .f argument, for more information.\n\n\ngapminder <-\n  dir(\"data\", full.names = TRUE) %>% \n  set_names(~ basename(.x) %>% str_remove(\"\\\\.csv\")) %>%\n  map_dfr(read_csv, .id = \"continent\")\n\n\n\nThe Imperative Programming Approach\nThere are other ways we could have gone about this. A common construct in programming languages is the so called for-loop. For every element of a vector, the body of the loop runs. For our example, it would look like this:\n\n\npaths <- dir(\"data\", full.names = TRUE)\nresults <- vector(\"list\", length(paths))\n\nfor (i in 1:length(paths)) {\n  data <- read_csv(paths[i])\n  results[[i]] <- data\n}\n\nnames(results) <- basename(paths) %>% str_remove(\"\\\\.csv\")\ngapminder <- bind_rows(results, .id = \"continent\")\n\n\n\nThe for-loop-version has a lot more code, especially boilerplate, code that is just there to make the construct work and doesn’t convey our intentions with the code. Furthermore, the loop focuses the object that is iterated over (the file paths), while the map-version focuses on what is happening (the function, read_csv). But the loop still works. If you can’t think of a way to solve a problem with a map function, it is absolutely OK to use for-loops.\nThe first approach with the map function comes from Functional Programming, whereas the second approach is considered Imperative Programming. In general, in Functional Programming, we tell the computer what we want, while in Imperative Programming, we tell the computer what steps to do. So keep in mind:\n\n»Of course someone has to write for-loops. It doesn’t have to be you.« — Jenny Bryan\n\nAnd don’t miss the amazing purrr cheatsheet: link\n“If you copy and paste the same code more than three times, write a function.”\nNoticing a Pattern\nWriting our own functions can be very helpful for making our code more readable. It allows us to separate certain steps of your analysis from the rest, look at them in isolation to test and validate them, and also allows us to give them reasonable names. Let’s look at a couple of examples and get you writing functions! Say we have this idea, where we filter the gapminder dataset for one country, check how linear the relationship between year and life expectancy is and then create a plot.\n\n\nfilterd_data <- gapminder %>% \n  filter(country == \"Norway\")\n\nmodel <- lm(lifeExp ~ year, data = filterd_data)\n\n\n\nThese three function from the broom package tell us more about our linear model created with lm. It is part of the tidymodels framework.\n\n\nbroom::tidy(model)\n\n\n# A tibble: 2 x 5\n  term        estimate std.error statistic      p.value\n  <chr>          <dbl>     <dbl>     <dbl>        <dbl>\n1 (Intercept) -185.     16.2         -11.4 0.000000460 \n2 year           0.132   0.00819      16.1 0.0000000176\n\n\n\nbroom::augment(model)\n\n\n# A tibble: 12 x 8\n   lifeExp  year .fitted  .resid .std.resid   .hat .sigma .cooksd\n     <dbl> <dbl>   <dbl>   <dbl>      <dbl>  <dbl>  <dbl>   <dbl>\n 1    72.7  1952    72.2  0.455       1.11  0.295   0.483 0.256  \n 2    73.4  1957    72.9  0.566       1.31  0.225   0.470 0.250  \n 3    73.5  1962    73.5 -0.0640     -0.143 0.169   0.516 0.00209\n 4    74.1  1967    74.2 -0.114      -0.249 0.127   0.515 0.00450\n 5    74.3  1972    74.9 -0.513      -1.10  0.0991  0.484 0.0671 \n 6    75.4  1977    75.5 -0.143      -0.306 0.0851  0.514 0.00434\n 7    76.0  1982    76.2 -0.203      -0.433 0.0851  0.511 0.00872\n 8    75.9  1987    76.8 -0.943      -2.03  0.0991  0.396 0.226  \n 9    77.3  1992    77.5 -0.172      -0.377 0.127   0.512 0.0103 \n10    78.3  1997    78.2  0.168       0.376 0.169   0.512 0.0144 \n11    79.0  2002    78.8  0.238       0.553 0.225   0.508 0.0443 \n12    80.2  2007    79.5  0.725       1.76  0.295   0.429 0.649  \n\n\n\nbroom::glance(model)\n\n\n# A tibble: 1 x 12\n  r.squared adj.r.squared sigma statistic p.value    df logLik   AIC\n      <dbl>         <dbl> <dbl>     <dbl>   <dbl> <dbl>  <dbl> <dbl>\n1     0.963         0.959 0.490      260. 1.76e-8     1  -7.37  20.7\n# … with 4 more variables: BIC <dbl>, deviance <dbl>,\n#   df.residual <int>, nobs <int>\n\nThe \\(R^2\\) value tells us, how well a straight line fits to our data. It can assume values between 0 and 1.\n\n\nmodel_glance <- broom::glance(model)\n\ntext <- substitute(R^2 == rsq,\n                   list(rsq = round(model_glance$r.squared, 2)))\n\nfilterd_data %>% \n  ggplot(aes(year, lifeExp)) +\n  geom_smooth(method = \"lm\") +\n  geom_line() +\n  geom_point() +\n  theme_classic() +\n  labs(\n    x = \"Year\",\n    y = \"Life Expectancy\",\n    title = \"Norway\",\n    subtitle = text\n  )\n\n\n\n\nThen we get curious and want to know how this graph looks for another country. So we copy and paste our code and replace the name of the country. And yet again, we want to see this plot for another country, so we copy and paste our code, change the country name and keep going. This is when we remember, that there is an easier way to deal with this repetition. We look at our code again and identify the things that stay the same and the things that change during each copy and pasting. The things that stay the same will be the body of our function, the things that change will be variables in the body that we pass to the function as arguments. In our example, there is only one thing that changes every time: the name of the country. So we build the following function:\n\n\nplot_life_exp_for_country <- function(country_name) {\n  filterd_data <- gapminder %>% \n    filter(country == country_name)\n  \n  model <- lm(lifeExp ~ year, data = filterd_data)\n  model_glance <- broom::glance(model)\n  text <- substitute(R^2 == rsq,\n                     list(rsq = round(model_glance$r.squared, 2)))\n  \n  filterd_data %>% \n    ggplot(aes(year, lifeExp)) +\n    geom_smooth(method = \"lm\") +\n    geom_line() +\n    geom_point() +\n    theme_classic() +\n    labs(\n      x = \"Year\",\n      y = \"Life Expectancy\",\n      title = country_name,\n      subtitle = text\n    )\n}\n\n\n\nThen we test the function a bunch to make sure it works for different cases:\n\n\nplot_life_exp_for_country(\"India\")\nplot_life_exp_for_country(\"Mali\")\n\n\n\n\nWhere to put your Functions\nAt this point you might wonder where to put this function. A good starting point is to collect your functions near the top of your document or script, below where you load all packages. Another approach, especially if you have functions that you can use for multiple projects, is to put them in a .R file and load this file at the beginning of your document. You can do so using the function source(\"path/to/file.R\"). It runs the R file in your current sessions, so any functions and variables defined in there are now available to you.\n\n\nsource(\"R/my_funs.R\")\n\n\n\nJust like this.\n\n\nsay_hello()\n\n\n[1] \"Hello!\"\n\nI like to store my regular R files (as opposed to Rmd files) in a folder of my project called R. This makes it already look like an R package, in case I decide later on that the functions could be helpful for others as well or I want to share them more easily with colleagues. You can read more about creating your own R packages here (Wickham 2015).\nMany Models\nLet us use the techniques above to shine light on how life expectancies changed over time. This time, we will utilize the nested data format to store our data alongside models for the data.\n\n\nnested_gapminder <- gapminder %>%\n  nest(-country, -continent) %>% \n  mutate(\n    model = map(data, ~ lm(lifeExp ~ year, data = .x))\n  )\n\nnested_gapminder\n\n\n# A tibble: 142 x 4\n   continent country                  data              model \n   <chr>     <chr>                    <list>            <list>\n 1 Africa    Algeria                  <tibble [12 × 4]> <lm>  \n 2 Africa    Angola                   <tibble [12 × 4]> <lm>  \n 3 Africa    Benin                    <tibble [12 × 4]> <lm>  \n 4 Africa    Botswana                 <tibble [12 × 4]> <lm>  \n 5 Africa    Burkina Faso             <tibble [12 × 4]> <lm>  \n 6 Africa    Burundi                  <tibble [12 × 4]> <lm>  \n 7 Africa    Cameroon                 <tibble [12 × 4]> <lm>  \n 8 Africa    Central African Republic <tibble [12 × 4]> <lm>  \n 9 Africa    Chad                     <tibble [12 × 4]> <lm>  \n10 Africa    Comoros                  <tibble [12 × 4]> <lm>  \n# … with 132 more rows\n\nThen, we extract information about the model with some functions form the broom package.\n\n\nnested_gapminder %>% \n  mutate(\n    glance = map(model, broom::glance)\n  )\n\n\n# A tibble: 142 x 5\n   continent country              data            model glance        \n   <chr>     <chr>                <list>          <lis> <list>        \n 1 Africa    Algeria              <tibble [12 × … <lm>  <tibble [1 × …\n 2 Africa    Angola               <tibble [12 × … <lm>  <tibble [1 × …\n 3 Africa    Benin                <tibble [12 × … <lm>  <tibble [1 × …\n 4 Africa    Botswana             <tibble [12 × … <lm>  <tibble [1 × …\n 5 Africa    Burkina Faso         <tibble [12 × … <lm>  <tibble [1 × …\n 6 Africa    Burundi              <tibble [12 × … <lm>  <tibble [1 × …\n 7 Africa    Cameroon             <tibble [12 × … <lm>  <tibble [1 × …\n 8 Africa    Central African Rep… <tibble [12 × … <lm>  <tibble [1 × …\n 9 Africa    Chad                 <tibble [12 × … <lm>  <tibble [1 × …\n10 Africa    Comoros              <tibble [12 × … <lm>  <tibble [1 × …\n# … with 132 more rows\n\nThen we go ahead and unnest the information about the model. We can now see, which countries stray the farthest from a straight line by arranging by the \\(R^2\\) values.\n\n\ngapminder_modeled <- nested_gapminder %>% \n  mutate(\n    glance = map(model, broom::glance)\n  ) %>% \n  unnest(glance) %>% \n  arrange(r.squared)\n\ngapminder_modeled\n\n\n# A tibble: 142 x 16\n   continent country data  model r.squared adj.r.squared sigma\n   <chr>     <chr>   <lis> <lis>     <dbl>         <dbl> <dbl>\n 1 Africa    Rwanda  <tib… <lm>     0.0172      -0.0811   6.56\n 2 Africa    Botswa… <tib… <lm>     0.0340      -0.0626   6.11\n 3 Africa    Zimbab… <tib… <lm>     0.0562      -0.0381   7.21\n 4 Africa    Zambia  <tib… <lm>     0.0598      -0.0342   4.53\n 5 Africa    Swazil… <tib… <lm>     0.0682      -0.0250   6.64\n 6 Africa    Lesotho <tib… <lm>     0.0849      -0.00666  5.93\n 7 Africa    Cote d… <tib… <lm>     0.283        0.212    3.93\n 8 Africa    South … <tib… <lm>     0.312        0.244    4.74\n 9 Africa    Uganda  <tib… <lm>     0.342        0.276    3.19\n10 Africa    Congo,… <tib… <lm>     0.348        0.283    2.43\n# … with 132 more rows, and 9 more variables: statistic <dbl>,\n#   p.value <dbl>, df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>,\n#   deviance <dbl>, df.residual <int>, nobs <int>\n\nFor a more detailed walk-trough, check out the chapter on “many models” in R for Data Science here (Wickham and Grolemund 2017).\nLet’s use this information to build a visualization.\n\n\nnon_linear_countries <- gapminder_modeled %>% \n  filter(r.squared < 0.2) %>% \n  unnest(data)\n\nnon_linear_countries\n\n\n# A tibble: 72 x 19\n   continent country  year lifeExp    pop gdpPercap model r.squared\n   <chr>     <chr>   <dbl>   <dbl>  <dbl>     <dbl> <lis>     <dbl>\n 1 Africa    Rwanda   1952    40   2.53e6      493. <lm>     0.0172\n 2 Africa    Rwanda   1957    41.5 2.82e6      540. <lm>     0.0172\n 3 Africa    Rwanda   1962    43   3.05e6      597. <lm>     0.0172\n 4 Africa    Rwanda   1967    44.1 3.45e6      511. <lm>     0.0172\n 5 Africa    Rwanda   1972    44.6 3.99e6      591. <lm>     0.0172\n 6 Africa    Rwanda   1977    45   4.66e6      670. <lm>     0.0172\n 7 Africa    Rwanda   1982    46.2 5.51e6      882. <lm>     0.0172\n 8 Africa    Rwanda   1987    44.0 6.35e6      848. <lm>     0.0172\n 9 Africa    Rwanda   1992    23.6 7.29e6      737. <lm>     0.0172\n10 Africa    Rwanda   1997    36.1 7.21e6      590. <lm>     0.0172\n# … with 62 more rows, and 11 more variables: adj.r.squared <dbl>,\n#   sigma <dbl>, statistic <dbl>, p.value <dbl>, df <dbl>,\n#   logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>,\n#   df.residual <int>, nobs <int>\n\nI also like to use this opportunity to mention a couple of packages to take your visualizations the the next level. Today, these are ggrepel to produce labels that dodge each other, and the fisualize package, which contains color scales of tropical fish.\n\n\nplt <- gapminder %>% \n  ggplot(aes(year, lifeExp, group = country)) +\n  geom_line(alpha = 0.2) +\n  geom_line(data = non_linear_countries,\n            mapping = aes(color = country),\n            size = 1.7) +\n  fishualize::scale_color_fish_d() +\n  labs(y = \"Life Expectancy at Birth\") +\n  ggrepel::geom_text_repel(data = filter(non_linear_countries, year == max(year)),\n            aes(label = country, color = country),\n            hjust = 0, direction = \"y\") +\n  expand_limits(x = 2015) +\n  theme_minimal() +\n  guides(color = \"none\")\n\nplt\n\n\n\n\nSometimes it is also very handy (and probably impressive to whoever receives your report) to turn a plot into an interactive graphic. plotly is a library that produces interactive plots, but we don’t even have to learn about its intricacies because it comes with a function to convert a ggplot to the interactive format that works quite well for a range (but not all) of use-cases:\n\n\nplotly::ggplotly(plt)\n\n\npreserve9ee2adc26673638f\n\nThe downward slope of our highlighted countries starting in the 1990s is a result of the ravaging AIDS pandemic. The prominent dips in two of the curves, orange for Rwanda and Cambodia in gray, are the direct consequences of genocides. These dire realities can in no way be summarized in just a couple of colorful lines. I am also in no way qualified to lecture on these topics. A good friend of mine, Timothy Williams, however is a researcher and teacher in the field of conflict and violence with a focus on genocides. He did field work in Cambodia and Rwanda and his book “The Complexity of Evil. Perpetration and Genocide” will be published here on December 18 (Williams, n.d.).\nAdvanced dplyr\nLast but not least, I want to mention a powerful advanced function in dplyr to make your data transformations even more efficient. It is the across function, which we can use inside of dplyr verbs such as mutate and summarise to use one or multiple functions on multiple columns. Let’s look at an example, again with the gapminder dataset. Now, this is sort of a silly example, but let’s say we want the continents and countries in UPPERCASE. We could do:\n\n\ngapminder %>% \n  mutate(\n    continent = str_to_upper(continent),\n    country = str_to_upper(country)\n  )\n\n\n# A tibble: 1,704 x 6\n   continent country  year lifeExp      pop gdpPercap\n   <chr>     <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n 1 AFRICA    ALGERIA  1952    43.1  9279525     2449.\n 2 AFRICA    ALGERIA  1957    45.7 10270856     3014.\n 3 AFRICA    ALGERIA  1962    48.3 11000948     2551.\n 4 AFRICA    ALGERIA  1967    51.4 12760499     3247.\n 5 AFRICA    ALGERIA  1972    54.5 14760787     4183.\n 6 AFRICA    ALGERIA  1977    58.0 17152804     4910.\n 7 AFRICA    ALGERIA  1982    61.4 20033753     5745.\n 8 AFRICA    ALGERIA  1987    65.8 23254956     5681.\n 9 AFRICA    ALGERIA  1992    67.7 26298373     5023.\n10 AFRICA    ALGERIA  1997    69.2 29072015     4797.\n# … with 1,694 more rows\n\nAnd now everyone is really shouty. But we had some repetition in our code. Wouldn’t it be cool, to just say: “Apply the function str_to_upper to these columns.”\n\n\ngapminder %>% \n  mutate(\n    across(c(continent, country), str_to_upper)\n  )\n\n\n# A tibble: 1,704 x 6\n   continent country  year lifeExp      pop gdpPercap\n   <chr>     <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n 1 AFRICA    ALGERIA  1952    43.1  9279525     2449.\n 2 AFRICA    ALGERIA  1957    45.7 10270856     3014.\n 3 AFRICA    ALGERIA  1962    48.3 11000948     2551.\n 4 AFRICA    ALGERIA  1967    51.4 12760499     3247.\n 5 AFRICA    ALGERIA  1972    54.5 14760787     4183.\n 6 AFRICA    ALGERIA  1977    58.0 17152804     4910.\n 7 AFRICA    ALGERIA  1982    61.4 20033753     5745.\n 8 AFRICA    ALGERIA  1987    65.8 23254956     5681.\n 9 AFRICA    ALGERIA  1992    67.7 26298373     5023.\n10 AFRICA    ALGERIA  1997    69.2 29072015     4797.\n# … with 1,694 more rows\n\nNot that is raw power! We can be even more general and ask R to apply the function to all columns that contain text:\n\n\ngapminder %>% \n  mutate(\n    across(where(is.character), str_to_upper)\n  )\n\n\n# A tibble: 1,704 x 6\n   continent country  year lifeExp      pop gdpPercap\n   <chr>     <chr>   <dbl>   <dbl>    <dbl>     <dbl>\n 1 AFRICA    ALGERIA  1952    43.1  9279525     2449.\n 2 AFRICA    ALGERIA  1957    45.7 10270856     3014.\n 3 AFRICA    ALGERIA  1962    48.3 11000948     2551.\n 4 AFRICA    ALGERIA  1967    51.4 12760499     3247.\n 5 AFRICA    ALGERIA  1972    54.5 14760787     4183.\n 6 AFRICA    ALGERIA  1977    58.0 17152804     4910.\n 7 AFRICA    ALGERIA  1982    61.4 20033753     5745.\n 8 AFRICA    ALGERIA  1987    65.8 23254956     5681.\n 9 AFRICA    ALGERIA  1992    67.7 26298373     5023.\n10 AFRICA    ALGERIA  1997    69.2 29072015     4797.\n# … with 1,694 more rows\n\nIt also works with summarise, for example to create summaries across a range of columns. And we can supply more than one function to calculate using a named list:\n\n\ngapminder %>% \n  summarise(\n    across(year:gdpPercap, list(mean = mean, total = sum))\n  )\n\n\n# A tibble: 1 x 8\n  year_mean year_total lifeExp_mean lifeExp_total pop_mean pop_total\n      <dbl>      <dbl>        <dbl>         <dbl>    <dbl>     <dbl>\n1     1980.    3373068         59.5       101344.   2.96e7   5.04e10\n# … with 2 more variables: gdpPercap_mean <dbl>,\n#   gdpPercap_total <dbl>\n\nYou are on you way to becoming a true data wizard! After today, you should be familiar with:\nimporting data into R\nthe concept of tidy data\nthe grammar of graphics\nthe basic dplyr verbs for data wrangling\na project-based workflow\nwriting and using functions\nWe will then use these foundations to experience statistical concepts ourselves in the next lectures.\nExercises\nThe whole Deal\nI want to get you playing around with data, so keep in mind that the solutions for this exercise are not set in stone. There is often more than one viable way of graphing the same dataset and we will use the Office Hour to talk about the advantages and disadvantages of approaches that you came up with.\nRoman emperors\nThe first exercise uses a dataset about roman emperors from the tidytuesday project (link). You can import it with:\n\n\nemperors <- readr::read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-08-13/emperors.csv\")\n\n\n\nHere are a couple of questions to answer. Decide for yourselves if a particular question is best answered using a visualization, a table or a simple sentence.\nWhat was the most popular way to rise to power?\nI what are the most common causes of death among roman emperors, what (or who) killed them?\nWhich dynasty was the most successful?\nFirstly, how often did each dynasty reign?\nSecondly, how long where the reigns?\nWhich dynasty would you rather be a part of, if your goal is to live the longest?\n\nDairy Products in the US\nAnother dataset (link) concerns dairy product consumption per person in the US across a number of years. Load it with\n\n\ndairy <- readr::read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-01-29/milk_products_facts.csv\")\n\n\n\nAll masses are given in lbs (pounds), can you convert them to kg?\nWhich products lost their customer base over time, which ones won?\nAbove all, have some fun! If you make interesting findings along the way, go ahead and produce plots to highlight it.\nResources\npurrr documentation\nstringr documentation\ndplyr documentation\n\n\n\nWickham, Hadley. 2015. R Packages: Organize, Test, Document, and Share Your Code. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\nWilliams, Timothy. n.d. “The Complexity of Evil.” Rutgers University Press.\n\n\n\n\n",
    "preview": "lectures/lecture4/lecture4_files/figure-html5/unnamed-chunk-18-1.png",
    "last_modified": "2020-11-23T01:37:16+01:00",
    "input_file": "lecture4.utf8.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "lectures/lecture3/",
    "title": "Lecture 3",
    "description": "... in which we explore the concept of Tidy Data, learn more\nadvanced data wrangling techniques and get a sneak peak at\niteration.",
    "author": [
      {
        "name": "Jannik Buhr",
        "url": "https://jmbuhr.de"
      }
    ],
    "date": "2020-11-14",
    "categories": [
      "lecture"
    ],
    "contents": "\n\nContents\nVideo\nSlides\nScript\nTidy data\nWhat and Why is Tidy Data?\nMaking Data Tidy\npivot_wider\nseparate\nleft_join\npivot_longer\nunite\nAnother Example\n\nMore Shapes for Data\nNested Data\n\nA Sneak Peak at Iteration\n\nExercises\nTidy Data\nFunctions and Iteration\n\nResources\n\nVideo\nWatch today’s video here:\n\n\nSlides\nHover over the slides and press f for full screen. Press ? for a list of keyboard shortcuts.\n\n\nknitr::include_url(\"slides3.html\")\n\n\n\n\n\nScript\nTidy data\nWhat and Why is Tidy Data?\nThere is one concept which also lends it’s name to the tidyverse that I want to talk about. Tidy Data is a way of turning your datasets into a uniform shape. This makes it easier to develop and work with tools because we get a consistent interface. Once you know how to turn any dataset into a tidy dataset, you are on home turf and can express your ideas more fluently in code. Getting there can sometimes be tricky, but I will give you the most important tools. Because…\n\n»Tidy datasets are all alike, but every messy dataset is messy in its own way.« — Hadley Wickham\n\nfreely adapted from:\n\n»Happy families are all alike; every unhappy family is unhappy in its own way.« — Leo Tolstoy\n\nSo, how can we recognize tidy data?\n\n\n\n\nFigure 1: Figure from https://r4ds.had.co.nz/tidy-data.html (Wickham and Grolemund 2017)\n\n\n\nIn tidy data, each variable (feature) forms it’s own column. Each observation forms a row. And each cell is a single value (measurement). Furthermore, information about the same things belongs in one table.\nThe tidyr package contained in the tidyverse provides small example datasets to demonstrate what this means in practice. Hadley Wickham and Garrett Grolemund use these in their book as well (https://r4ds.had.co.nz/tidy-data.html)(Wickham and Grolemund 2017).\ntable1, table2, table3, table4a, table4b, and table5 all display the number of TB cases documented by the World Health Organization in Afghanistan, Brazil, and China between 1999 and 2000. The first of these is in the tidy format, the others are not:\n\n\nlibrary(tidyverse)\n\n# The paged_table function from the rmarkdown package prints the tables\n# for the rmarkdown html document format so that it looks nice in the script.\n# Alternatively you could use\n# knitr's kable function\npaged_table(table1)\n\n\n\n\n{\"columns\":[{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"cases\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"population\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"1999\",\"3\":\"745\",\"4\":\"19987071\"},{\"1\":\"Afghanistan\",\"2\":\"2000\",\"3\":\"2666\",\"4\":\"20595360\"},{\"1\":\"Brazil\",\"2\":\"1999\",\"3\":\"37737\",\"4\":\"172006362\"},{\"1\":\"Brazil\",\"2\":\"2000\",\"3\":\"80488\",\"4\":\"174504898\"},{\"1\":\"China\",\"2\":\"1999\",\"3\":\"212258\",\"4\":\"1272915272\"},{\"1\":\"China\",\"2\":\"2000\",\"3\":\"213766\",\"4\":\"1280428583\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\nThis nicely qualifies as tidy data. Every row is uniquely identified by the country and year, and all other columns are properties of the specific country in this specific year.\n\n\npaged_table(table2)\n\n\n\n\n{\"columns\":[{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"type\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"count\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"1999\",\"3\":\"cases\",\"4\":\"745\"},{\"1\":\"Afghanistan\",\"2\":\"1999\",\"3\":\"population\",\"4\":\"19987071\"},{\"1\":\"Afghanistan\",\"2\":\"2000\",\"3\":\"cases\",\"4\":\"2666\"},{\"1\":\"Afghanistan\",\"2\":\"2000\",\"3\":\"population\",\"4\":\"20595360\"},{\"1\":\"Brazil\",\"2\":\"1999\",\"3\":\"cases\",\"4\":\"37737\"},{\"1\":\"Brazil\",\"2\":\"1999\",\"3\":\"population\",\"4\":\"172006362\"},{\"1\":\"Brazil\",\"2\":\"2000\",\"3\":\"cases\",\"4\":\"80488\"},{\"1\":\"Brazil\",\"2\":\"2000\",\"3\":\"population\",\"4\":\"174504898\"},{\"1\":\"China\",\"2\":\"1999\",\"3\":\"cases\",\"4\":\"212258\"},{\"1\":\"China\",\"2\":\"1999\",\"3\":\"population\",\"4\":\"1272915272\"},{\"1\":\"China\",\"2\":\"2000\",\"3\":\"cases\",\"4\":\"213766\"},{\"1\":\"China\",\"2\":\"2000\",\"3\":\"population\",\"4\":\"1280428583\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\nNow it gets interesting. table2 still looks organized, but it is not tidy (by our definition). Note, this doesn’t say the format is useless — it has it’s places — but it will not fit in as snugly with our tools. The column type is not a feature of the country, rather the actual features are hidden in that column with their values in the count column. In order to make it tidy, this dataset would need to get wider.\n\n\npaged_table(table3)\n\n\n\n\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"rate\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"1999\",\"3\":\"745/19987071\",\"_rn_\":\"1\"},{\"1\":\"Afghanistan\",\"2\":\"2000\",\"3\":\"2666/20595360\",\"_rn_\":\"2\"},{\"1\":\"Brazil\",\"2\":\"1999\",\"3\":\"37737/172006362\",\"_rn_\":\"3\"},{\"1\":\"Brazil\",\"2\":\"2000\",\"3\":\"80488/174504898\",\"_rn_\":\"4\"},{\"1\":\"China\",\"2\":\"1999\",\"3\":\"212258/1272915272\",\"_rn_\":\"5\"},{\"1\":\"China\",\"2\":\"2000\",\"3\":\"213766/1280428583\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\nIn table3, two features are jammed into one column. This is annoying, because we can’t easily calculate with the values; they are stored as text and separated by a slash like cases/population. Ideally, we would want to separate this column into two.\n\n\npaged_table(table4a)\n\n\n\n\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"1999\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"2000\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"745\",\"3\":\"2666\",\"_rn_\":\"1\"},{\"1\":\"Brazil\",\"2\":\"37737\",\"3\":\"80488\",\"_rn_\":\"2\"},{\"1\":\"China\",\"2\":\"212258\",\"3\":\"213766\",\"_rn_\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\n\n\npaged_table(table4b)\n\n\n\n\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"1999\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"2000\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"19987071\",\"3\":\"20595360\",\"_rn_\":\"1\"},{\"1\":\"Brazil\",\"2\":\"172006362\",\"3\":\"174504898\",\"_rn_\":\"2\"},{\"1\":\"China\",\"2\":\"1272915272\",\"3\":\"1280428583\",\"_rn_\":\"3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\ntable4a and table4b split the data into two different tables, which again makes it harder to calculate with. This data is so closely related, we would want it in one table. And another principle of tidy data is violated. Notice the column names? 1999 is not a feature that Afghanistan can have. Rather, it is the value for a feature (namely the year), while the values in the 1999 column are in fact values for the feature population (in table4a) and cases (in table4b).\n\n\npaged_table(table5)\n\n\n\n\n{\"columns\":[{\"label\":[\"\"],\"name\":[\"_rn_\"],\"type\":[\"\"],\"align\":[\"left\"]},{\"label\":[\"country\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"century\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"rate\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"Afghanistan\",\"2\":\"19\",\"3\":\"99\",\"4\":\"745/19987071\",\"_rn_\":\"1\"},{\"1\":\"Afghanistan\",\"2\":\"20\",\"3\":\"00\",\"4\":\"2666/20595360\",\"_rn_\":\"2\"},{\"1\":\"Brazil\",\"2\":\"19\",\"3\":\"99\",\"4\":\"37737/172006362\",\"_rn_\":\"3\"},{\"1\":\"Brazil\",\"2\":\"20\",\"3\":\"00\",\"4\":\"80488/174504898\",\"_rn_\":\"4\"},{\"1\":\"China\",\"2\":\"19\",\"3\":\"99\",\"4\":\"212258/1272915272\",\"_rn_\":\"5\"},{\"1\":\"China\",\"2\":\"20\",\"3\":\"00\",\"4\":\"213766/1280428583\",\"_rn_\":\"6\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\nIn table5, we have the same problem as in table3 and additionally the opposite problem! This time, feature that should be one column (namely year) is spread across two columns (century and year). What we want to do is unite those into one.\nMaking Data Tidy\n\n\n\n\n\nwith the tidyr package.\n\nNote: I do not go over data is better in another format in this course. Examples for this might involve matrices to benefit from matrix math or their multidimensional equivalent: arrays.\n\nLet’s make some data tidy!\npivot_wider\nStarting with table2, which wants to be wider. Accordingly, we use the function pivot_wider. It is very powerful, but the two most important arguments (well, after the data) are which column contains the names of the new columns and which column contains the values of the newly created columns as shown below.\n\n\ntable2 %>% \n  pivot_wider(names_from = type, values_from = count)\n\n\n# A tibble: 6 x 4\n  country      year  cases population\n  <chr>       <int>  <int>      <int>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\nseparate\nTo make table3 tidy, we need the separate function, followed by mutate to get the new columns into the correct datatype. Run it yourself step by step to see why the mutate afterwards is necessary.\n\n\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"), sep = \"/\") %>% \n  mutate(cases = parse_number(cases),\n         population = parse_number(population))\n\n\n# A tibble: 6 x 4\n  country      year  cases population\n  <chr>       <int>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\nThe parse_ functions come from readr. Parsing is the act of turning raw text into usable data, and the parse_number function does a particularly good job at extracting numbers, where the naïve approach of as.numeric might fail e.g.\n\n\nsome_text = \"take my number: 12\"\nas.numeric(some_text)\n\n\n[1] NA\n\n\n\nparse_number(some_text)\n\n\n[1] 12\n\nleft_join\nNow is the time to join table4a and tabl4b together. For this, we need an operation known from databases as a join. In fact, this whole concept of tidy data is closely related to databases and something called Codd`s normal forms (Codd 1990; Wickham 2014) so I am throwing these references in here just in case you are interested in the theoretical foundations. But without further ado:\n\n\n# the suffix argument is necessary because the columns\n# in the two tables have the same names\ntable4 <- left_join(table4a, table4b, by = \"country\",\n                    suffix = c(\"_cases\", \"_population\"))\ntable4\n\n\n# A tibble: 3 x 5\n  country  `1999_cases` `2000_cases` `1999_populatio… `2000_populatio…\n  <chr>           <int>        <int>            <int>            <int>\n1 Afghani…          745         2666         19987071         20595360\n2 Brazil          37737        80488        172006362        174504898\n3 China          212258       213766       1272915272       1280428583\n\npivot_longer\nNow we can deal with the next problem: Making the table longer so that year, population and cases become their own columns again, because they are independent features. Consequently, we use the function pivot_longer:\n\n\n# note that cols takes what is called a tidyselect specification.\n# you know this from the selection function and it's help page.\n# here, I am selecting everything BUT the country column.\nlong_table4 <- table4 %>% \n  pivot_longer(cols = -country)\nlong_table4\n\n\n# A tibble: 12 x 3\n   country     name                 value\n   <chr>       <chr>                <int>\n 1 Afghanistan 1999_cases             745\n 2 Afghanistan 2000_cases            2666\n 3 Afghanistan 1999_population   19987071\n 4 Afghanistan 2000_population   20595360\n 5 Brazil      1999_cases           37737\n 6 Brazil      2000_cases           80488\n 7 Brazil      1999_population  172006362\n 8 Brazil      2000_population  174504898\n 9 China       1999_cases          212258\n10 China       2000_cases          213766\n11 China       1999_population 1272915272\n12 China       2000_population 1280428583\n\nBut we are not done yet, table4 is putting all our skills to the test. There is a way to do the following steps with pivot_wider straight away, but doing it step by step should be easier to follow. You can revisit this part and check out the other arguments to pivot_wider if you fancy a challenge. The next step we already know: separating a column into two. Only the separator changed.\n\n\nlong_table4_separated <- long_table4 %>% \n  separate(col = name, into = c(\"year\", \"type\"), sep = \"_\")\nlong_table4_separated\n\n\n# A tibble: 12 x 4\n   country     year  type            value\n   <chr>       <chr> <chr>           <int>\n 1 Afghanistan 1999  cases             745\n 2 Afghanistan 2000  cases            2666\n 3 Afghanistan 1999  population   19987071\n 4 Afghanistan 2000  population   20595360\n 5 Brazil      1999  cases           37737\n 6 Brazil      2000  cases           80488\n 7 Brazil      1999  population  172006362\n 8 Brazil      2000  population  174504898\n 9 China       1999  cases          212258\n10 China       2000  cases          213766\n11 China       1999  population 1272915272\n12 China       2000  population 1280428583\n\nNow we are back to the problem we had in table2, so we know how to make this table wider again:\n\n\nlong_table4_separated %>% \n  pivot_wider(names_from = type, values_from = value)\n\n\n# A tibble: 6 x 4\n  country     year   cases population\n  <chr>       <chr>  <int>      <int>\n1 Afghanistan 1999     745   19987071\n2 Afghanistan 2000    2666   20595360\n3 Brazil      1999   37737  172006362\n4 Brazil      2000   80488  174504898\n5 China       1999  212258 1272915272\n6 China       2000  213766 1280428583\n\nWe did it! Now one last look at table5, which contains a case we haven’t encountered yet: a feature is separated across two columns, so we need the opposite of separeate: unite.\nunite\n\n\ntable5 %>% \n  unite(col = year, c(century, year), sep = \"\") %>% \n  mutate(year = parse_number(year))\n\n\n# A tibble: 6 x 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n\nAnother Example\nLet us look at one last example of data that needs tidying, which is also provided by the tidyr package as an example:\n\n\nhead(billboard) %>% paged_table()\n\n\n\n\n{\"columns\":[{\"label\":[\"artist\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"track\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"date.entered\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"wk1\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk2\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk3\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk4\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk5\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk6\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk7\"],\"name\":[10],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk8\"],\"name\":[11],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk9\"],\"name\":[12],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk10\"],\"name\":[13],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk11\"],\"name\":[14],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk12\"],\"name\":[15],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk13\"],\"name\":[16],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk14\"],\"name\":[17],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk15\"],\"name\":[18],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk16\"],\"name\":[19],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk17\"],\"name\":[20],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk18\"],\"name\":[21],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk19\"],\"name\":[22],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk20\"],\"name\":[23],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk21\"],\"name\":[24],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk22\"],\"name\":[25],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk23\"],\"name\":[26],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk24\"],\"name\":[27],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk25\"],\"name\":[28],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk26\"],\"name\":[29],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk27\"],\"name\":[30],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk28\"],\"name\":[31],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk29\"],\"name\":[32],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk30\"],\"name\":[33],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk31\"],\"name\":[34],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk32\"],\"name\":[35],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk33\"],\"name\":[36],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk34\"],\"name\":[37],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk35\"],\"name\":[38],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk36\"],\"name\":[39],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk37\"],\"name\":[40],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk38\"],\"name\":[41],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk39\"],\"name\":[42],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk40\"],\"name\":[43],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk41\"],\"name\":[44],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk42\"],\"name\":[45],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk43\"],\"name\":[46],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk44\"],\"name\":[47],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk45\"],\"name\":[48],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk46\"],\"name\":[49],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk47\"],\"name\":[50],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk48\"],\"name\":[51],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk49\"],\"name\":[52],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk50\"],\"name\":[53],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk51\"],\"name\":[54],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk52\"],\"name\":[55],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk53\"],\"name\":[56],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk54\"],\"name\":[57],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk55\"],\"name\":[58],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk56\"],\"name\":[59],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk57\"],\"name\":[60],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk58\"],\"name\":[61],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk59\"],\"name\":[62],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk60\"],\"name\":[63],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk61\"],\"name\":[64],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk62\"],\"name\":[65],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk63\"],\"name\":[66],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk64\"],\"name\":[67],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk65\"],\"name\":[68],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"wk66\"],\"name\":[69],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk67\"],\"name\":[70],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk68\"],\"name\":[71],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk69\"],\"name\":[72],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk70\"],\"name\":[73],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk71\"],\"name\":[74],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk72\"],\"name\":[75],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk73\"],\"name\":[76],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk74\"],\"name\":[77],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk75\"],\"name\":[78],\"type\":[\"lgl\"],\"align\":[\"right\"]},{\"label\":[\"wk76\"],\"name\":[79],\"type\":[\"lgl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"2000-02-26\",\"4\":\"87\",\"5\":\"82\",\"6\":\"72\",\"7\":\"77\",\"8\":\"87\",\"9\":\"94\",\"10\":\"99\",\"11\":\"NA\",\"12\":\"NA\",\"13\":\"NA\",\"14\":\"NA\",\"15\":\"NA\",\"16\":\"NA\",\"17\":\"NA\",\"18\":\"NA\",\"19\":\"NA\",\"20\":\"NA\",\"21\":\"NA\",\"22\":\"NA\",\"23\":\"NA\",\"24\":\"NA\",\"25\":\"NA\",\"26\":\"NA\",\"27\":\"NA\",\"28\":\"NA\",\"29\":\"NA\",\"30\":\"NA\",\"31\":\"NA\",\"32\":\"NA\",\"33\":\"NA\",\"34\":\"NA\",\"35\":\"NA\",\"36\":\"NA\",\"37\":\"NA\",\"38\":\"NA\",\"39\":\"NA\",\"40\":\"NA\",\"41\":\"NA\",\"42\":\"NA\",\"43\":\"NA\",\"44\":\"NA\",\"45\":\"NA\",\"46\":\"NA\",\"47\":\"NA\",\"48\":\"NA\",\"49\":\"NA\",\"50\":\"NA\",\"51\":\"NA\",\"52\":\"NA\",\"53\":\"NA\",\"54\":\"NA\",\"55\":\"NA\",\"56\":\"NA\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"},{\"1\":\"2Ge+her\",\"2\":\"The Hardest Part Of ...\",\"3\":\"2000-09-02\",\"4\":\"91\",\"5\":\"87\",\"6\":\"92\",\"7\":\"NA\",\"8\":\"NA\",\"9\":\"NA\",\"10\":\"NA\",\"11\":\"NA\",\"12\":\"NA\",\"13\":\"NA\",\"14\":\"NA\",\"15\":\"NA\",\"16\":\"NA\",\"17\":\"NA\",\"18\":\"NA\",\"19\":\"NA\",\"20\":\"NA\",\"21\":\"NA\",\"22\":\"NA\",\"23\":\"NA\",\"24\":\"NA\",\"25\":\"NA\",\"26\":\"NA\",\"27\":\"NA\",\"28\":\"NA\",\"29\":\"NA\",\"30\":\"NA\",\"31\":\"NA\",\"32\":\"NA\",\"33\":\"NA\",\"34\":\"NA\",\"35\":\"NA\",\"36\":\"NA\",\"37\":\"NA\",\"38\":\"NA\",\"39\":\"NA\",\"40\":\"NA\",\"41\":\"NA\",\"42\":\"NA\",\"43\":\"NA\",\"44\":\"NA\",\"45\":\"NA\",\"46\":\"NA\",\"47\":\"NA\",\"48\":\"NA\",\"49\":\"NA\",\"50\":\"NA\",\"51\":\"NA\",\"52\":\"NA\",\"53\":\"NA\",\"54\":\"NA\",\"55\":\"NA\",\"56\":\"NA\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"},{\"1\":\"3 Doors Down\",\"2\":\"Kryptonite\",\"3\":\"2000-04-08\",\"4\":\"81\",\"5\":\"70\",\"6\":\"68\",\"7\":\"67\",\"8\":\"66\",\"9\":\"57\",\"10\":\"54\",\"11\":\"53\",\"12\":\"51\",\"13\":\"51\",\"14\":\"51\",\"15\":\"51\",\"16\":\"47\",\"17\":\"44\",\"18\":\"38\",\"19\":\"28\",\"20\":\"22\",\"21\":\"18\",\"22\":\"18\",\"23\":\"14\",\"24\":\"12\",\"25\":\"7\",\"26\":\"6\",\"27\":\"6\",\"28\":\"6\",\"29\":\"5\",\"30\":\"5\",\"31\":\"4\",\"32\":\"4\",\"33\":\"4\",\"34\":\"4\",\"35\":\"3\",\"36\":\"3\",\"37\":\"3\",\"38\":\"4\",\"39\":\"5\",\"40\":\"5\",\"41\":\"9\",\"42\":\"9\",\"43\":\"15\",\"44\":\"14\",\"45\":\"13\",\"46\":\"14\",\"47\":\"16\",\"48\":\"17\",\"49\":\"21\",\"50\":\"22\",\"51\":\"24\",\"52\":\"28\",\"53\":\"33\",\"54\":\"42\",\"55\":\"42\",\"56\":\"49\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"},{\"1\":\"3 Doors Down\",\"2\":\"Loser\",\"3\":\"2000-10-21\",\"4\":\"76\",\"5\":\"76\",\"6\":\"72\",\"7\":\"69\",\"8\":\"67\",\"9\":\"65\",\"10\":\"55\",\"11\":\"59\",\"12\":\"62\",\"13\":\"61\",\"14\":\"61\",\"15\":\"59\",\"16\":\"61\",\"17\":\"66\",\"18\":\"72\",\"19\":\"76\",\"20\":\"75\",\"21\":\"67\",\"22\":\"73\",\"23\":\"70\",\"24\":\"NA\",\"25\":\"NA\",\"26\":\"NA\",\"27\":\"NA\",\"28\":\"NA\",\"29\":\"NA\",\"30\":\"NA\",\"31\":\"NA\",\"32\":\"NA\",\"33\":\"NA\",\"34\":\"NA\",\"35\":\"NA\",\"36\":\"NA\",\"37\":\"NA\",\"38\":\"NA\",\"39\":\"NA\",\"40\":\"NA\",\"41\":\"NA\",\"42\":\"NA\",\"43\":\"NA\",\"44\":\"NA\",\"45\":\"NA\",\"46\":\"NA\",\"47\":\"NA\",\"48\":\"NA\",\"49\":\"NA\",\"50\":\"NA\",\"51\":\"NA\",\"52\":\"NA\",\"53\":\"NA\",\"54\":\"NA\",\"55\":\"NA\",\"56\":\"NA\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"},{\"1\":\"504 Boyz\",\"2\":\"Wobble Wobble\",\"3\":\"2000-04-15\",\"4\":\"57\",\"5\":\"34\",\"6\":\"25\",\"7\":\"17\",\"8\":\"17\",\"9\":\"31\",\"10\":\"36\",\"11\":\"49\",\"12\":\"53\",\"13\":\"57\",\"14\":\"64\",\"15\":\"70\",\"16\":\"75\",\"17\":\"76\",\"18\":\"78\",\"19\":\"85\",\"20\":\"92\",\"21\":\"96\",\"22\":\"NA\",\"23\":\"NA\",\"24\":\"NA\",\"25\":\"NA\",\"26\":\"NA\",\"27\":\"NA\",\"28\":\"NA\",\"29\":\"NA\",\"30\":\"NA\",\"31\":\"NA\",\"32\":\"NA\",\"33\":\"NA\",\"34\":\"NA\",\"35\":\"NA\",\"36\":\"NA\",\"37\":\"NA\",\"38\":\"NA\",\"39\":\"NA\",\"40\":\"NA\",\"41\":\"NA\",\"42\":\"NA\",\"43\":\"NA\",\"44\":\"NA\",\"45\":\"NA\",\"46\":\"NA\",\"47\":\"NA\",\"48\":\"NA\",\"49\":\"NA\",\"50\":\"NA\",\"51\":\"NA\",\"52\":\"NA\",\"53\":\"NA\",\"54\":\"NA\",\"55\":\"NA\",\"56\":\"NA\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"},{\"1\":\"98^0\",\"2\":\"Give Me Just One Nig...\",\"3\":\"2000-08-19\",\"4\":\"51\",\"5\":\"39\",\"6\":\"34\",\"7\":\"26\",\"8\":\"26\",\"9\":\"19\",\"10\":\"2\",\"11\":\"2\",\"12\":\"3\",\"13\":\"6\",\"14\":\"7\",\"15\":\"22\",\"16\":\"29\",\"17\":\"36\",\"18\":\"47\",\"19\":\"67\",\"20\":\"66\",\"21\":\"84\",\"22\":\"93\",\"23\":\"94\",\"24\":\"NA\",\"25\":\"NA\",\"26\":\"NA\",\"27\":\"NA\",\"28\":\"NA\",\"29\":\"NA\",\"30\":\"NA\",\"31\":\"NA\",\"32\":\"NA\",\"33\":\"NA\",\"34\":\"NA\",\"35\":\"NA\",\"36\":\"NA\",\"37\":\"NA\",\"38\":\"NA\",\"39\":\"NA\",\"40\":\"NA\",\"41\":\"NA\",\"42\":\"NA\",\"43\":\"NA\",\"44\":\"NA\",\"45\":\"NA\",\"46\":\"NA\",\"47\":\"NA\",\"48\":\"NA\",\"49\":\"NA\",\"50\":\"NA\",\"51\":\"NA\",\"52\":\"NA\",\"53\":\"NA\",\"54\":\"NA\",\"55\":\"NA\",\"56\":\"NA\",\"57\":\"NA\",\"58\":\"NA\",\"59\":\"NA\",\"60\":\"NA\",\"61\":\"NA\",\"62\":\"NA\",\"63\":\"NA\",\"64\":\"NA\",\"65\":\"NA\",\"66\":\"NA\",\"67\":\"NA\",\"68\":\"NA\",\"69\":\"NA\",\"70\":\"NA\",\"71\":\"NA\",\"72\":\"NA\",\"73\":\"NA\",\"74\":\"NA\",\"75\":\"NA\",\"76\":\"NA\",\"77\":\"NA\",\"78\":\"NA\",\"79\":\"NA\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\nThis is a lot of columns! For 76 weeks after a song entered the top 100 (I assume in the USA) it’s position is recorded. It might be in this format because it made data entry easier, or the previous person wanted to make plots in excel, where this wide format is used to denote multiple traces. In any event, for our style of visualizations with the grammar of graphics, we want a column to represent a feature, so this data needs to get longer:\n\n\nlong_billboard <- billboard %>% \n  pivot_longer(starts_with(\"w\"),\n               names_to = \"week\",\n               names_pattern = \"wk(\\\\d+)\",\n               values_to = \"placement\",\n               values_drop_na = TRUE) %>% \n  mutate(week = parse_integer(week),\n         date = as.Date(date.entered) + 7 * (week - 1)) %>% \n  select(-date.entered)\n\nlong_billboard %>% \n  head() %>% \n  paged_table()\n\n\n\n\n{\"columns\":[{\"label\":[\"artist\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"track\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"week\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"placement\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"date\"],\"name\":[5],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"1\",\"4\":\"87\",\"5\":\"2000-02-26\"},{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"2\",\"4\":\"82\",\"5\":\"2000-03-04\"},{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"3\",\"4\":\"72\",\"5\":\"2000-03-11\"},{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"4\",\"4\":\"77\",\"5\":\"2000-03-18\"},{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"5\",\"4\":\"87\",\"5\":\"2000-03-25\"},{\"1\":\"2 Pac\",\"2\":\"Baby Don't Cry (Keep...\",\"3\":\"6\",\"4\":\"94\",\"5\":\"2000-04-01\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  \n\n\nThis time I am leaving the visualisation up to you. This is a greate opportunity to play around with ggplot!\n\nThis whole tidy data idea might seem like just another way of moving numbers around. But once you build the mental model for it, it will truly transform the way you are able to think about data. Both for data wrangling with dplyr, as shown last week, and also for data visualization with ggplot, a journey we began in the first week and that is still well underway.\nMore Shapes for Data\nThe tidyr package provides more tools for dealing with data in various shapes. We just discovered the first set of operations called pivoting to get a feel for tidy data and to obtain it from various formats. But data is not always rectangular like we can show it in a spreadsheet. Sometimes data already comes in a nested form, sometimes we create nested data because it serves our purpose (see next week). So, what do I mean by nested?\nNested Data\nRemember that lists can contain elements of any type, even other lists? Well, if have have a list that contains more lists, we call it nested. E.g.\n\n\nlist(\n  c(1, 2),\n  list(\n    42, list(\"hi\", TRUE)\n  )\n)\n\n\n[[1]]\n[1] 1 2\n\n[[2]]\n[[2]][[1]]\n[1] 42\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] \"hi\"\n\n[[2]][[2]][[2]]\n[1] TRUE\n\nBut nested list are not always fun to work with, and when there is a straightforward way to represent the same data in a rectangular, flat format, we most likely want to do that. We will deal with data rectangling today was well. But first, there is another implication of nested lists: Because dataframes (and tibbles) are built on top of lists, we can nest them to! This can sometimes come in really handy. We a dataframe contains a column that is not an atomic vector but a list (so it is a list in a list), we call it a list column:\n\n\nexample <- tibble(\n  x = 1:3,\n  y = list(\"hello\", TRUE, c(1,2,3,4))\n)\nexample\n\n\n# A tibble: 3 x 2\n      x y        \n  <int> <list>   \n1     1 <chr [1]>\n2     2 <lgl [1]>\n3     3 <dbl [4]>\n\nHere, the output in our code only tells us, that the list column y contains an atomic character vector of length 1, a logical vector of length 1 and a double vector of length 4. The overall length of the column is 3, because it has to fit in the tibble.\nWe can get a better view of what is in there by either pulling the column out with the subsetting functions we already learned (like $, [[]], pull), using str to learn more about the structure or simply using RStudio’s Environment panel to inspect our variable. Click on the name to view it in a new window (the same can be done from code by using the function View or Ctrl+Clicking the variable name) or use the little blue arrow to expand the list.\n\n\ninclude_graphics(\"img/environment.png\")\n\n\n\n\nThis extends even further, we are about to go full inception on this! A list column can contain tibbles (/dataframes) as well!\n\n\nnested_tibble <- tibble(\n  id = 1:2,\n  df = list(\n    tibble(x = 1:10, y = x^2),\n    tibble(x = seq(1, 100, 3), y = sqrt(x))\n  )\n)\n\nnested_tibble\n\n\n# A tibble: 2 x 2\n     id df               \n  <int> <list>           \n1     1 <tibble [10 × 2]>\n2     2 <tibble [34 × 2]>\n\nWe can still use the data nested in there, as long as we remember how to chain our subsetting functions together.\n\n\n# take the column df, take the second element\nnested_tibble$df[[2]]\n\n\n# A tibble: 34 x 2\n       x     y\n   <dbl> <dbl>\n 1     1  1   \n 2     4  2   \n 3     7  2.65\n 4    10  3.16\n 5    13  3.61\n 6    16  4   \n 7    19  4.36\n 8    22  4.69\n 9    25  5   \n10    28  5.29\n# … with 24 more rows\n\nA handy way to subsett into nested structures is with the pluck function:\n\n\nnested_tibble %>% pluck(\"df\", 2)\n\n\n# A tibble: 34 x 2\n       x     y\n   <dbl> <dbl>\n 1     1  1   \n 2     4  2   \n 3     7  2.65\n 4    10  3.16\n 5    13  3.61\n 6    16  4   \n 7    19  4.36\n 8    22  4.69\n 9    25  5   \n10    28  5.29\n# … with 24 more rows\n\n\n\nnested_tibble$df[[2]] %>% \n  ggplot(aes(x, y)) +\n  geom_line() +\n  geom_point() + \n  theme_minimal()\n\n\n\n\nThis will be incredibly useful next week, when we talk about iteration.\nCreating a tibble by hand is unlikely going to be the way that you end up with a nested tibble. Let’s create one from an already existing tibble. We can use the long version of the billboard dataset we created above.\n\n\nnested_billboard <- long_billboard %>% \n  nest(data = c(-artist, -track))\n\nhead(nested_billboard)\n\n\n# A tibble: 6 x 3\n  artist       track                   data             \n  <chr>        <chr>                   <list>           \n1 2 Pac        Baby Don't Cry (Keep... <tibble [7 × 3]> \n2 2Ge+her      The Hardest Part Of ... <tibble [3 × 3]> \n3 3 Doors Down Kryptonite              <tibble [53 × 3]>\n4 3 Doors Down Loser                   <tibble [20 × 3]>\n5 504 Boyz     Wobble Wobble           <tibble [18 × 3]>\n6 98^0         Give Me Just One Nig... <tibble [20 × 3]>\n\nNotice, how similar this is to group_by, except it is much more explicit. The resulting groups are now separated into their own tibble in the list column I named data. Again, RStudio’s environment panel makes it easier to inspect the data.\nWe can get back to our original shape by unnesting the tibble\n\n\nnested_billboard %>% \n  unnest(data) %>% \n  head()\n\n\n# A tibble: 6 x 5\n  artist track                    week placement date      \n  <chr>  <chr>                   <int>     <dbl> <date>    \n1 2 Pac  Baby Don't Cry (Keep...     1        87 2000-02-26\n2 2 Pac  Baby Don't Cry (Keep...     2        82 2000-03-04\n3 2 Pac  Baby Don't Cry (Keep...     3        72 2000-03-11\n4 2 Pac  Baby Don't Cry (Keep...     4        77 2000-03-18\n5 2 Pac  Baby Don't Cry (Keep...     5        87 2000-03-25\n6 2 Pac  Baby Don't Cry (Keep...     6        94 2000-04-01\n\nUnnesting is one special case for the general idea of data rectangling, for which the tidyr package provides more functions. Unfortunately, we can’t all explore them all today.\nA Sneak Peak at Iteration\nNext week we are going to explore the concept of iteration, having R do one operation for multiple things. But today, I am already giving you a sneak peak at how nested data can help us in that respect. It will also make sure you get more comfortable with writing functions.\nLet us take just one dataset out of the many datasets:\n\n\none_track <- nested_billboard$data[[1]]\none_track\n\n\n# A tibble: 7 x 3\n   week placement date      \n  <int>     <dbl> <date>    \n1     1        87 2000-02-26\n2     2        82 2000-03-04\n3     3        72 2000-03-11\n4     4        77 2000-03-18\n5     5        87 2000-03-25\n6     6        94 2000-04-01\n7     7        99 2000-04-08\n\nThis contains the performance of one song. we can create a plot of it:\n\n\nggplot(one_track, aes(week, placement)) +\n  geom_line() +\n  theme_linedraw()\n\n\n\n\nMoreover, we can create a function, that takes some data and creates a plot from it:\n\n\nplot_song_performance <- function(song_data) {\n  ggplot(song_data, aes(week, placement)) +\n    geom_line() +\n    theme_linedraw()\n}\n\n\n\nWe can now pass any song data from the nested dataframe to it:\n\n\nplot_song_performance(nested_billboard$data[[1]])\n\n\n\n\nBut we are more ambitious, we want this plot for all songs! The map function from the purrr package takes a list and a function and applies the function to all elements of the list. It is really powerful (and fun). We will learn all about it next week, but here is a preview:\n\n\n\n\n\n\n\nsong_performance <- nested_billboard %>% \n   mutate(\n      plt = map(data, plot_song_performance)\n   )\n\nsong_performance %>% head()\n\n\n# A tibble: 6 x 4\n  artist       track                   data              plt   \n  <chr>        <chr>                   <list>            <list>\n1 2 Pac        Baby Don't Cry (Keep... <tibble [7 × 3]>  <gg>  \n2 2Ge+her      The Hardest Part Of ... <tibble [3 × 3]>  <gg>  \n3 3 Doors Down Kryptonite              <tibble [53 × 3]> <gg>  \n4 3 Doors Down Loser                   <tibble [20 × 3]> <gg>  \n5 504 Boyz     Wobble Wobble           <tibble [18 × 3]> <gg>  \n6 98^0         Give Me Just One Nig... <tibble [20 × 3]> <gg>  \n\nAnd now we can look at individual plots:\n\n\nsong_performance$plt[[24]]\n\n\n\n\nIt might have been handy to include a title for the plot, so let’s modify our plotting function a little bit:\n\n\nplot_song_performance <- function(song_data, title) {\n  ggplot(song_data, aes(week, placement)) +\n    geom_line() +\n    theme_linedraw() +\n    labs(title = title)\n}\n\n\n\nAnd now we use the function map2 instead of map, which iterates over two vectors at the same time to also pass the plot title:\n\n\nsong_performance <- nested_billboard %>% \n   mutate(\n      plt = map2(data, track,  plot_song_performance)\n   )\n\nsong_performance$plt[[1]]\n\n\n\n\nWhen we don’t care about the return value of a function, but rather about the side-effect it has, we use the walk function in place of map. A side-effect is anything that changes the state of your program or the world around it, as opposed to pure functions, which only depend on their arguments return some value. Writing to a file for example is a side effect:\n\n\ndir.create(\"plts\")\n\nsave_plot <- function(name, plot) {\n  ggsave(paste0(\"plts/\", name, \".png\"), plot)\n}\n\nwalk2(song_performance$track, song_performance$plt, save_plot)\n\n\n\nDo try this at home, it feels quite good to achieve so much with one key-press!\nExercises\nTidy Data\nImagine for a second this whole pandemic thing is not going on and we are planning a vacation. Of course, we want to choose the safest airline possible, so we download data about incident reports. You can find it in the data folder1.\nInstead of the type_of_event and n_events columns we would like to have one column per type of event, where the values are the count for this event.\nWhich airlines had the least fatal accidents, standardized to the distance theses airlines covered, in the two time ranges?\nEven if something where to go wrong, which airlines have the best record when it comes to fatalities per fatal accident?\nCreate an informative plot to highlight your discoveries. It might be beneficial to only plot e.g. the highest or lowest scoring Airlines. One of the slice_ functions will help you there. And to make your plot prettier, you will have to look into fct_reorder again.\nFunctions and Iteration\nYou are going strong so far! Programming can sometimes be frustrating, so I think what we need is someone to motivate us. R is up to the task. Write a function that takes a name, like “Jannik” or your name, and spits out a motivational message that includes the name. Make sure to also test it and show that it works.\nNow that you have a motivational machine, you need to make sure to motivate the greatest amount of people. Use the map function to apply your function to a whole vector of names.\nResources\ntidyr documentation\npurrr documentation\nstringr documentation for working with text and a helpful cheatsheet for the regular expressions mentioned in the video\n\n\n\nCodd, E. F. 1990. The Relational Model for Database Management: Version 2. USA: Addison-Wesley Longman Publishing Co., Inc.\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software 59 (1): 1–23. https://doi.org/10.18637/jss.v059.i10.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\nsource: tidytuesday↩︎\n",
    "preview": "lectures/lecture3/img/tidy-data-wickham.png",
    "last_modified": "2020-11-15T23:31:53+01:00",
    "input_file": "lecture3.utf8.md",
    "preview_width": 1920,
    "preview_height": 600
  },
  {
    "path": "lectures/lecture2/",
    "title": "Lecture 2",
    "description": "... in which we explore the typical data analysis workflow\nwith the tidyverse, wrangle different kinds of data and\nlearn about factors.",
    "author": [
      {
        "name": "Jannik Buhr",
        "url": "https://jmbuhr.de"
      }
    ],
    "date": "2020-11-07",
    "categories": [
      "lecture"
    ],
    "contents": "\n\nContents\nVideo\nSlides\nScript\nMaking Ourselves at Home in RStudio\nImportant Settings\nA Project-based Workflow\nWorking in Style\n\nA Data Analysis Workflow\nReading Data with readr\nCommon Hurdles when Importing Data\n\nWrangling Data with dplyr\nselect\nfilter\nmutate\nInterlude: Begind the magic, handling data with base-R\nThe pipe %>%\narrange\nsummarise\ngroup_by\n\nVisualization and our First Encounter with factors\n\nExercises\nResources\nPackage Documentation\nGetting Help\n\n\nVideo\n\n\nSlides\n\n\n\n\nScript\n\nNote:\nI try to be vocal about what the code does in plain English while I type it and learning the “translations” of symbols and keywords can help you, too. After a while, programming can feel a lot more like having a conversation with your digital assistant or a helpful friend. The boundary between human languages and computer languages is more blurry than you might think.\n\nBefore we get deeper into R, let’s talk a little bit about our Home when working with R: RStudio.\nMaking Ourselves at Home in RStudio\nImportant Settings\nI highlighted 3 settings that I consider important to change from their default values. The first two might seem odd at first glance.\n\n\n\nThe workspace that RStudio would save as .RData contains all objects created in a session, which is, what we can see in the Environment pane (by default in the top right panel, bottom right in my setup). Why would we not want to load the objects we created in the last session into our current session automatically? The reason is reproducibility. We want to make sure that everything our analysis needs is in the script. It creates our variables and plots from the raw data and should be the sole source of truth. Given the raw data and the script, everyone should be able to reproduce our results. The third setting (text encoding) is also concerned with collaboration. It makes sure that our text files and special characters in them (like German umlauts) look the same on different operating systems like Windows, iOS and Linux.\nA Project-based Workflow\nLast week we simply went ahead and created a script file and an Rmarkdown file in some folder on our computer. But how does R known, where the script is? How does it know, where to look, when we tell it to read in a file or save a plot? The main folder where R starts is called the working directory. To find out, what our current working directory is, we execute the function getwd() for get working directory:\n\n\ngetwd()\n\n\n[1] \"/home/jannik/Documents/projects/teaching/dataIntro20/_lectures/lecture2\"\n\nThis will look slightly different depending on you operating system. The next function I want you to know, but never use:\n\n\nsetwd(\"some/file/path\")\n\n\n\n“Why should I not use it?” you might ask. Let’s assume I use the function to set the working directory as seen above:\n\n\nsetwd(\"/home/jannik/Documents/projects/teaching/dataIntro20/_lectures/lecture2\")\n\n\n\nNow, when I give the file to you to test my analysis, chances are very low that it would work. Because you are likely not called Jannik and even more likely don’t have the same folder structure that I had.\nSo what we want instead of these absolute file paths, is a relative file paths that start in the folder that our scripts are in. This is what RStudio Projects are for. It is basically just a folder with a special file that ends in .Rproj, but as soon as R finds this file in the folder, the working directory will automatically be this folder. So when you share this folder, it will still just work.\nGo ahead and use the blue R button in the top right corner to create a New Project. I recommend you do this either as one project for the whole course or with one project per week. Projects are also convenient because they save what files you had open and so forth.\nThere is one thing I didn’t tell you about Rmarkdown documents, yet. Their working directory is always the folder they are in, even if they are in some subdirectory of a project. In a way this also means that you don’t necessarily need a project to work with Rmarkdown, but having one anyway makes it easier to keep track of your files and have a consistent structure.\nWorking in Style\nNow that we have a cosy project for today, let’s also make sure we are working in style and are feeling right at home in RStudio. This blogpost provides excellent gifs for the different settings in RStudio and even for Rmarkdown troubleshooting. I am also fond of the rsthemes package for additional appearances.\nA Data Analysis Workflow\nWe are getting close to importing our very first dataset from a file into R. Generally, this is the first thing that needs to happen with any data analysis and we will cover it today. The data I provided is already pretty tidy so we will start with that and build some visualizations. The communicate-part is also covered, because we are working in Rmarkdown after all, which is designed to communicate our findings. Later, we will also have a look at some less tidy data, but not before having defined what “tidy data” is.\n\n\n\n\nFigure 1: Figure from Wickham and Grolemund (2017).\n\n\n\nReading Data with readr\n\n\n\n\n\nThe package responsible for loading data in the tidyverse is called readr, so we start by loading the whole tidyverse.\nNote, that in general, we could also load just the readr package with library(readr), but we need the rest of the tidyverse later on anyways. There is also the option to not load a package at all but rather only use one function from a package by prefixing the function with the package name and two colons (::) Like so: readr::read_csv(\"...\").\n\n\nlibrary(tidyverse)\n\n\n\nWithout further ado, let’s download the data for today. In fact, there are multiple ways to go about this. We could download the whole course folder from GitHub by following the link in the top right corner of this website and then using the download button:\n\n\n\nYou will then find the data in the folder ./_lectures/lecture2/data/.\nOr we can navigate to the file on GitHub. Follow this link: files, click on one of the files and then click on raw:\n\n\n\nFrom there you can copy the link displayed in your browser address field and download the file straight from R:\n\n\ndownload.file(\"https://raw.githubusercontent.com/jmbuhr/dataIntro20/master/_lectures/lecture2/data/gapminder.csv\",\n              \"data/gapminder.csv\")\n\n\n\nThe folder to download your data to (./data) must be created in advance. This is an example for a relative path (an absolute path would start with / or a drive letter like C:).\nNow we can finally load in the data and store it in a variable. When working with file paths, RStudio’s autocompletion is especially helpful. We can trigger it with Tab or Ctrl+Space.\n\n\ngapminder <- read_csv(\"data/gapminder.csv\")\n\n\n\nreadr will also tell you the datatypes it guessed for the columns. Let’s inspect our dataset:\n\n\ngapminder\n\n\n# A tibble: 1,704 x 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,694 more rows\n\nThe gapminder dataset (Bryan 2017) is an excerpt from the gapminder project and contains the life expectancy at birth for 142 countries at 5 year intervals between 1952 and 2007. It also contains the population and the Gross Domestic Product (GDP) per Inhabitant. We will built a visualization later on.\nread_csv can even read data from a url straight away, without the need for us to download the file ourselves, but we usually want a copy of the data locally. For the curious run this:\n\n\nread_csv(\"https://raw.githubusercontent.com/jmbuhr/dataIntro20/master/_lectures/lecture2/data/gapminder.csv\")\n\n\n\nSo, this all went smoothly. But this will not always be the case. We will now look at common hurdles when importing data\nCommon Hurdles when Importing Data\nThe function we just used was called read_csv, because it reads a file format that consists of comma separated values. Look at the raw file in a text editor (not word) like notepad or RStudio to see why. But the file extension .csv can sometimes be lying…\nBecause in German, the comma is used to separate decimal numbers (vs. the dot in English), a lot of Software will output a different type of csv-file when configured in German. It will still call it csv, but actually it is separated by semicolons! We have a special function for this:\n\n\nread_csv2(\"data/gapminder_csv2.csv\")\n\n\n\nWhen looking through the autocompletion options that pop up when you are typing the function name, you might have noticed a similar function read.csv and read.csv2. These are the functions that come with R, without any packages like the tidyverse. You can of course use those as well, but the tidyverse functions provide a more consistent experience and have less surprising quirks. I am teaching the tidyverse first, because it allows you to do more while having to learn less edge cases.\nIf we look at yet another file data/gapminder_tsv.txt, we notice that the file extension doesn’t tell us much about the format, only that it is text (as opposed to a binary format only computers can read). If we look into the file:\n\n\nread_lines(\"data/gapminder_tsv.txt\", n_max = 3)\n\n\n[1] \"country\\tcontinent\\tyear\\tlifeExp\\tpop\\tgdpPercap\"    \n[2] \"Afghanistan\\tAsia\\t1952\\t28.801\\t8425333\\t779.4453145\"\n[3] \"Afghanistan\\tAsia\\t1957\\t30.332\\t9240934\\t820.8530296\"\n\nWe notice that the values are separated by \", a special sequence that stands for the tab character. The read_tsv function will do the job.\nIf the separator (also called delimiter) is even more obscure, we can use the general function read_delim. Say a co-worker misunderstood us and thought tsv stands for “Tilde separated values,” we can still read his file.\n\n\nread_lines(\"data/obscure_file.tsv\", n_max = 3)\n\n\n[1] \"country~continent~year~lifeExp~pop~gdpPercap\"    \n[2] \"Afghanistan~Asia~1952~28.801~8425333~779.4453145\"\n[3] \"Afghanistan~Asia~1957~30.332~9240934~820.8530296\"\n\n\n\nread_delim(\"data/obscure_file.tsv\", delim = \"~\")\n\n\n\nThere are more ways in which raw data can be messy or hard to read depending on the machine but I can’t show all of them. One common thing you will encounter though is measurement machines writing some additional information in the first couple of lines before the actual data (like the time of the measurement). In this example:\n\n\nread_lines(\"data/gapminder_messier.csv\", n_max = 4)\n\n\n[1] \"# Some comment about the data\"                   \n[2] \"And maybe a personal note\"                       \n[3] \"country,continent,year,lifeExp,pop,gdpPercap\"    \n[4] \"Afghanistan,Asia,1952,28.801,8425333,779.4453145\"\n\nThe first 2 lines are not part of the data. Reading the file normally as a csv would produce something weird: Because the first line does not contain any commata, it will assume that the file contains only one column and also report a bunch of parsing failures. Parsing is the act of turning data represented as raw text into a useful format, like a table of numbers.\n\n\nread_csv(\"data/gapminder_messier.csv\", n_max = 3)\n\n\n# A tibble: 3 x 1\n  `# Some comment about the data`\n  <chr>                          \n1 And maybe a personal note      \n2 country                        \n3 Afghanistan                    \n\nWe can fix this by telling R to skip the first 2 lines entirely:\n\n\nread_csv(\"data/gapminder_messier.csv\", skip = 2, n_max = 3)\n\n\n# A tibble: 3 x 6\n  country     continent  year lifeExp      pop gdpPercap\n  <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n\nI was using the n_max argument of the functions above to save space in this lecture script.\nIn the video I forgot to mention that I also included an excel file to practice. We can read it using a function from the readxl package. This package is automatically installed with the tidyverse, but it is not loaded along with the other packages via library(tidyverse). We can either load it with library(readxl) or refer to a single function from the package without loading the whole thing using double colons (::):\n\n\nreadxl::read_xlsx(\"./data/gapminder.xlsx\")\n\n\n\nNow, that we learned about some of the ways in which raw data can be structured, let us go back to the original data that we read in and saved in the variable gapminder.\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.4453\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.8530\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.1007\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.1971\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.9811\nAfghanistan\nAsia\n1977\n38.438\n14880372\n786.1134\n\nWrangling Data with dplyr\n\n\n\n\n\nThere a are a number of ways in which we can manipulate data. Of course I mean manipulate in it’s original sense, not the malicious one. This is sometimes referred to as data wrangling and within the tidyverse, this is a job for the dplyr package (short for data plyer, the tool you see in the logo).\ndplyr provides functions for various operations on our data. Theses functions are sometimes also called dplyr verbs. All of them take a tibble or data.frame as input (plus additional parameters) and always return a tibble.\n\n\n\nFigure 2: (“Artwork by @allison_horst” 2020)\n\n\n\nselect\nThe first verb we introduce is used to select columns. And hence, it is called select. The first argument is always the data, followed by an arbitrary number of column names. We can recognize functions the take an arbitrary number of additional arguments by the ... in the autocompletion and help page.\n\n\nselect(gapminder, country, year, pop)\n\n\n# A tibble: 1,704 x 3\n   country      year      pop\n   <chr>       <dbl>    <dbl>\n 1 Afghanistan  1952  8425333\n 2 Afghanistan  1957  9240934\n 3 Afghanistan  1962 10267083\n 4 Afghanistan  1967 11537966\n 5 Afghanistan  1972 13079460\n 6 Afghanistan  1977 14880372\n 7 Afghanistan  1982 12881816\n 8 Afghanistan  1987 13867957\n 9 Afghanistan  1992 16317921\n10 Afghanistan  1997 22227415\n# … with 1,694 more rows\n\nIt might be confusing why we don’t need quotation marks around the column names like we do when we select and element from a vector by name as in:\n\n\nc(first = 1, second = 2)[\"first\"]\n\n\nfirst \n    1 \n\nThis concept is known as quasiquotation or data masking. It is quite unique to R, but it allows functions to known about the content of the data that is passed to them and use this as the environment in which they do their computations and search for variable names. So while the variable country doesn’t exist in the global environment, it does exist as a column of the gapminder tibble. dplyr functions always look in the data first when they search for names.\nThe help page for select tells us more about the different ways in which we can select columns. Here are a couple of examples without the output, rum them in your R session to confirm that they do what you think they do. (but do have a look at the help pages yourselves, they are quite well written).\n\n\nselect(gapminder, where(is.numeric))\nselect(gapminder, country:lifeExp)\nselect(gapminder, starts_with(\"c\"))\nselect(gapminder, c(1, 3, 4))\n\n\n\nfilter\n\n\n\nFigure 3: (“Artwork by @allison_horst” 2020)\n\n\n\nAfter selecting columns it is only natural to ask how to select rows. This is achieved with the function filter. For example, we can filter for all years smaller than 2000:\n\n\nfilter(gapminder, year < 2000)\n\n\n# A tibble: 1,420 x 6\n   country     continent  year lifeExp      pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# … with 1,410 more rows\n\nOr all the rows where the country is “New Zealand”:\n\n\nfilter(gapminder, country == \"New Zealand\")\n\n\n# A tibble: 12 x 6\n   country     continent  year lifeExp     pop gdpPercap\n   <chr>       <chr>     <dbl>   <dbl>   <dbl>     <dbl>\n 1 New Zealand Oceania    1952    69.4 1994794    10557.\n 2 New Zealand Oceania    1957    70.3 2229407    12247.\n 3 New Zealand Oceania    1962    71.2 2488550    13176.\n 4 New Zealand Oceania    1967    71.5 2728150    14464.\n 5 New Zealand Oceania    1972    71.9 2929100    16046.\n 6 New Zealand Oceania    1977    72.2 3164900    16234.\n 7 New Zealand Oceania    1982    73.8 3210650    17632.\n 8 New Zealand Oceania    1987    74.3 3317166    19007.\n 9 New Zealand Oceania    1992    76.3 3437674    18363.\n10 New Zealand Oceania    1997    77.6 3676187    21050.\n11 New Zealand Oceania    2002    79.1 3908037    23190.\n12 New Zealand Oceania    2007    80.2 4115771    25185.\n\nmutate\nWe are back at manipulating columns, this time by creating new ones or changing old ones. The dplyr verb that does that is called muate. For example, we might want to calculate the total GDP from the GDP per Capita and the population:\n\n\nmutate(gapminder, gdp = pop * gdpPercap)\n\n\n# A tibble: 1,704 x 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>        <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# … with 1,694 more rows\n\nNotice, that none of the functions changed the original variable gapminder. They only take an input and return and output, which makes it easier to reason about our code and later chain pieces of code together. How do you change it then? Use the Force! … ahem, I mean, the assignment operator (<-).\n\n\ngapminder <- mutate(gapminder, gdp = pop * gdpPercap)\n\n\n\nHere, the power of dplyr shines. It knows that pop and gdpPercap are columns of the tibble and that gdp refers to the new name of the freshly created column.\nInterlude: Begind the magic, handling data with base-R\nThis section is meant to show you what happens behind the scenes. It is not strictly necessary to understand all the details of it in order to work effectively with the tidyverse, but it helps especially when things don’t go as planned.\nSo let’s look into handling data with base-R. Last week we briefly covered subsetting of vectors by their indices, their names, or a logical vector:\n\n\nx <- c(42, 1, 13, 29)\nnames(x) <- c(\"first\", \"second\", \"third\", \"fourth\")\nx\n\n\n first second  third fourth \n    42      1     13     29 \n\n\n\nx[c(1,3)]\n\n\nfirst third \n   42    13 \n\n\n\nx[c(\"first\", \"second\")]\n\n\n first second \n    42      1 \n\n\n\nx[c(TRUE, FALSE, FALSE, TRUE)]\n\n\n first fourth \n    42     29 \n\nThis subsetting with a logical vector can be used to filter the vector:\n\n\nselect_this <- x < 20\nselect_this\n\n\n first second  third fourth \n FALSE   TRUE   TRUE  FALSE \n\n\n\nx[select_this]\n\n\nsecond  third \n     1     13 \n\nWith data in 2 dimensions, rows and columns, subsetting works similarly. Let’s use the function tibble to create a tibble from vectors:\n\n\nmy_data <- tibble(\n  x = c(42, 1, 13, 29),\n  y = c(1, 2, 3, 4),\n  z = c(\"z1\", \"z2\", \"z3\", \"z4\")\n)\nmy_data\n\n\n# A tibble: 4 x 3\n      x     y z    \n  <dbl> <dbl> <chr>\n1    42     1 z1   \n2     1     2 z2   \n3    13     3 z3   \n4    29     4 z4   \n\n\nNote:\nR is not whitespace sensitive (like python). That means indentation doesn’t change the meaning of the code. We can use this to format our code to look pretty, which is why I started a new line after the opening bracket of tibble(.\n\nSubsetting a tibble like a vector selects columns:\n\n\nmy_data[c(1, 3)]\n\n\n# A tibble: 4 x 2\n      x z    \n  <dbl> <chr>\n1    42 z1   \n2     1 z2   \n3    13 z3   \n4    29 z4   \n\nBut if you pass two arguments to the square brackets, separated by commata, we can filter rows and select columns Here, we get the first row in the second and third columns:\n\n\nmy_data[1, c(2, 3)]\n\n\n# A tibble: 1 x 2\n      y z    \n  <dbl> <chr>\n1     1 z1   \n\nIf we follow the logic above, we can also filter the data. The comma without any argument afterwards selects all columns.\n\n\nmy_data[my_data$x < 20, ]\n\n\n# A tibble: 2 x 3\n      x     y z    \n  <dbl> <dbl> <chr>\n1     1     2 z2   \n2    13     3 z3   \n\nAt first glance, the tidyverse way of doing the same is only a little bit shorter. But apart from the fact that we don’t have to repeat the name of the data object my_data (because filter knows where to look for x, whereas [] doesn’t), there is another advantage.\n\n\nfilter(my_data, x < 20)\n\n\n# A tibble: 2 x 3\n      x     y z    \n  <dbl> <dbl> <chr>\n1     1     2 z2   \n2    13     3 z3   \n\nThe pipe %>%\nThe tidyverse functions are easier to compose (i.e. chain together). To facilitate this, we introduce another operator, a bit like + for numbers or the + to add ggplot components, but specially for functions. The pipe, which you can either type or insert in RStudio with Ctrl+Shift+M, takes it’s left side and passes it as the first argument to the function on the right side:\n\n\nmy_data %>% select(x, z)\n\n\n# A tibble: 4 x 2\n      x z    \n  <dbl> <chr>\n1    42 z1   \n2     1 z2   \n3    13 z3   \n4    29 z4   \n\nAnd because all main tidyverse functions take data as their first argument, we can chain them together fluently. Additionally, it enables autocompletion of column names inside of the function that gets the data. So back to the gapminder example:\n\n\ngapminder %>% \n  filter(year > 2000) %>% \n  mutate(gdp = pop * gdpPercap) %>% \n  select(country, year, gdp)\n\n\n# A tibble: 284 x 3\n   country      year           gdp\n   <chr>       <dbl>         <dbl>\n 1 Afghanistan  2002  18363410424.\n 2 Afghanistan  2007  31079291949.\n 3 Albania      2002  16153932130.\n 4 Albania      2007  21376411360.\n 5 Algeria      2002 165447670333.\n 6 Algeria      2007 207444851958.\n 7 Angola       2002  30134833901.\n 8 Angola       2007  59583895818.\n 9 Argentina    2002 337223430800.\n10 Argentina    2007 515033625357.\n# … with 274 more rows\n\nIt also reads much nicer in your head, which makes reasoning about the code easier. Without telling you what the above code did, you can understand it, because it reads like English. You can often pronounce the pipe as “and then” in your head, or out-loud, I’m not judging.\n\nNote:\nThe base-R and the tidyverse way are not mutually exclusive. Sometimes you can mix and match.\n\narrange\nA simple thing you might want from a table is to sort it based on some column. This is what arrange does:\n\n\ngapminder %>% \n  arrange(year)\n\n\n# A tibble: 1,704 x 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>        <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.      6.57e 9\n 2 Albania     Europe     1952    55.2  1282697     1601.      2.05e 9\n 3 Algeria     Africa     1952    43.1  9279525     2449.      2.27e10\n 4 Angola      Africa     1952    30.0  4232095     3521.      1.49e10\n 5 Argentina   Americas   1952    62.5 17876956     5911.      1.06e11\n 6 Australia   Oceania    1952    69.1  8691212    10040.      8.73e10\n 7 Austria     Europe     1952    66.8  6927772     6137.      4.25e10\n 8 Bahrain     Asia       1952    50.9   120447     9867.      1.19e 9\n 9 Bangladesh  Asia       1952    37.5 46886859      684.      3.21e10\n10 Belgium     Europe     1952    68    8730405     8343.      7.28e10\n# … with 1,694 more rows\n\nThe helper function desc marks a column to be arranged in descending order. We can arrange by multiple columns, where the first will be most important.\n\n\ngapminder %>% \n  arrange(desc(year), pop) %>% \n  select(country, year, pop) %>% \n  rename(population = pop)\n\n\n# A tibble: 1,704 x 3\n   country                year population\n   <chr>                 <dbl>      <dbl>\n 1 Sao Tome and Principe  2007     199579\n 2 Iceland                2007     301931\n 3 Djibouti               2007     496374\n 4 Equatorial Guinea      2007     551201\n 5 Montenegro             2007     684736\n 6 Bahrain                2007     708573\n 7 Comoros                2007     710960\n 8 Reunion                2007     798094\n 9 Trinidad and Tobago    2007    1056608\n10 Swaziland              2007    1133066\n# … with 1,694 more rows\n\nI also introduced the rename verb without warning. It does what it says it does, only the order of the names might be confusing. The new name comes first (like when you are creating a new column with mutate). You can also rename within select:\n\n\ngapminder %>% select(country, year, population = pop)\n\n\n# A tibble: 1,704 x 3\n   country      year population\n   <chr>       <dbl>      <dbl>\n 1 Afghanistan  1952    8425333\n 2 Afghanistan  1957    9240934\n 3 Afghanistan  1962   10267083\n 4 Afghanistan  1967   11537966\n 5 Afghanistan  1972   13079460\n 6 Afghanistan  1977   14880372\n 7 Afghanistan  1982   12881816\n 8 Afghanistan  1987   13867957\n 9 Afghanistan  1992   16317921\n10 Afghanistan  1997   22227415\n# … with 1,694 more rows\n\nsummarise\nTo condense one or multiple columns into summary values, we use summarise: Like with mutate, we can calculate multiple things in one step.\n\n\ngapminder %>% \n  summarise(\n    last_year = max(year),\n    average_pop = mean(pop),\n    minimal_gdp = min(gdp)\n  )\n\n\n# A tibble: 1 x 3\n  last_year average_pop minimal_gdp\n      <dbl>       <dbl>       <dbl>\n1      2007   29601212.   52784691.\n\nBut condensing whole columns into one value, flattening the tibble in the style of Super Mario jumping on mushrooms, is often not what we need. We would rather know the summaries within certain groups. For example the maximal gdp per country. This is what group_by is for.\ngroup_by\ngroup_by is considered an adverb, because it doesn’t change the data itself but it changes how subsequent functions handle the data. For example, if a tibble has groups, all summaries are calculated within these groups:\n\n\ngapminder %>% \n  group_by(country)\n\n\n# A tibble: 1,704 x 7\n# Groups:   country [142]\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>        <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# … with 1,694 more rows\n\nFor example, let’s look at the range of the life expectancy for each country:\n\n\ngapminder %>% \n  group_by(country) %>% \n  summarise(lower_life_exp = min(lifeExp),\n            upper_life_exp = max(lifeExp))\n\n\n# A tibble: 142 x 3\n   country     lower_life_exp upper_life_exp\n   <chr>                <dbl>          <dbl>\n 1 Afghanistan           28.8           43.8\n 2 Albania               55.2           76.4\n 3 Algeria               43.1           72.3\n 4 Angola                30.0           42.7\n 5 Argentina             62.5           75.3\n 6 Australia             69.1           81.2\n 7 Austria               66.8           79.8\n 8 Bahrain               50.9           75.6\n 9 Bangladesh            37.5           64.1\n10 Belgium               68             79.4\n# … with 132 more rows\n\nsummarize removes one level of grouping. If the data was grouped by multiple features, this means that some groups remain. We can make sure that the data is no longer grouped with ungroup.\n\n\ngapminder %>% \n  group_by(continent, year) %>% \n  summarise(mean_gdpPercap = mean(gdpPercap)) %>% \n  ungroup()\n\n\n# A tibble: 60 x 3\n   continent  year mean_gdpPercap\n   <chr>     <dbl>          <dbl>\n 1 Africa     1952          1253.\n 2 Africa     1957          1385.\n 3 Africa     1962          1598.\n 4 Africa     1967          2050.\n 5 Africa     1972          2340.\n 6 Africa     1977          2586.\n 7 Africa     1982          2482.\n 8 Africa     1987          2283.\n 9 Africa     1992          2282.\n10 Africa     1997          2379.\n# … with 50 more rows\n\nGroups also work within mutate and filter. For example, we can get all rows where the gdp per Person was highest per country:\n\n\ngapminder %>%\n  group_by(country) %>% \n  filter(gdpPercap == max(gdpPercap))\n\n\n# A tibble: 142 x 7\n# Groups:   country [142]\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>        <dbl>\n 1 Afghanistan Asia       1982    39.9   1.29e7      978.      1.26e10\n 2 Albania     Europe     2007    76.4   3.60e6     5937.      2.14e10\n 3 Algeria     Africa     2007    72.3   3.33e7     6223.      2.07e11\n 4 Angola      Africa     1967    36.0   5.25e6     5523.      2.90e10\n 5 Argentina   Americas   2007    75.3   4.03e7    12779.      5.15e11\n 6 Australia   Oceania    2007    81.2   2.04e7    34435.      7.04e11\n 7 Austria     Europe     2007    79.8   8.20e6    36126.      2.96e11\n 8 Bahrain     Asia       2007    75.6   7.09e5    29796.      2.11e10\n 9 Bangladesh  Asia       2007    64.1   1.50e8     1391.      2.09e11\n10 Belgium     Europe     2007    79.4   1.04e7    33693.      3.50e11\n# … with 132 more rows\n\nOr we can use groups in mutate to find out, what percentage of it’s continent a country’s population makes up per year:\n\n\ngapminder %>% \n  group_by(continent, year) %>% \n  mutate(pctPop = pop / sum(pop) * 100)\n\n\n# A tibble: 1,704 x 8\n# Groups:   continent, year [60]\n   country   continent  year lifeExp     pop gdpPercap      gdp pctPop\n   <chr>     <chr>     <dbl>   <dbl>   <dbl>     <dbl>    <dbl>  <dbl>\n 1 Afghanis… Asia       1952    28.8  8.43e6      779.  6.57e 9  0.604\n 2 Afghanis… Asia       1957    30.3  9.24e6      821.  7.59e 9  0.591\n 3 Afghanis… Asia       1962    32.0  1.03e7      853.  8.76e 9  0.605\n 4 Afghanis… Asia       1967    34.0  1.15e7      836.  9.65e 9  0.605\n 5 Afghanis… Asia       1972    36.1  1.31e7      740.  9.68e 9  0.608\n 6 Afghanis… Asia       1977    38.4  1.49e7      786.  1.17e10  0.624\n 7 Afghanis… Asia       1982    39.9  1.29e7      978.  1.26e10  0.494\n 8 Afghanis… Asia       1987    40.8  1.39e7      852.  1.18e10  0.483\n 9 Afghanis… Asia       1992    41.7  1.63e7      649.  1.06e10  0.521\n10 Afghanis… Asia       1997    41.8  2.22e7      635.  1.41e10  0.657\n# … with 1,694 more rows\n\nSometimes you want to refer to the size of the current group inside of mutate or summarise. The function to to just that is called n(). For example, I wonder how many rows of data we have per year.\n\n\ngapminder %>% \n  group_by(year) %>% \n  summarise(n = n())\n\n\n# A tibble: 12 x 2\n    year     n\n   <dbl> <int>\n 1  1952   142\n 2  1957   142\n 3  1962   142\n 4  1967   142\n 5  1972   142\n 6  1977   142\n 7  1982   142\n 8  1987   142\n 9  1992   142\n10  1997   142\n11  2002   142\n12  2007   142\n\nA shortcut for group_by and summarise with n() is the count function:\n\n\ngapminder %>% \n  count(year)\n\n\n# A tibble: 12 x 2\n    year     n\n   <dbl> <int>\n 1  1952   142\n 2  1957   142\n 3  1962   142\n 4  1967   142\n 5  1972   142\n 6  1977   142\n 7  1982   142\n 8  1987   142\n 9  1992   142\n10  1997   142\n11  2002   142\n12  2007   142\n\nIn general, you might find after solving a particular problem in a couple of steps that there is a more elegant solution. Do not be discouraged by that! It simply means that there is always more to learn, but the tools you already know by now will get you a very long way and set you on the right track.\nI think we learned enough dplyr verbs for now. We can treat ourselves to a little ggplot visualization.\nVisualization and our First Encounter with factors\n\n\ngapminder %>% \n  ggplot(aes(year, lifeExp, group = country)) +\n  geom_line(alpha = 0.3) +\n  facet_wrap(~ continent)\n\n\n\n\nThe facet_wrap function slices our plot into theses subplots, a style of plot sometimes referred to as small multiples. At this point you might wonder: “How do I control the order of these facets?” The answer is: With a factor! Any time we have a vector that can be thought of as representing discrete categories (ordered or unordered), we can express this by turning the vector into a factor with the factor function. This enables R’s functions to handle them appropriately. Let’s create a little example. We start out with a character vector.\n\n\nanimals <- c(\"cat\", \"dog\", \"parrot\", \"whale shark\", \"bear\")\nanimals\n\n\n[1] \"cat\"         \"dog\"         \"parrot\"      \"whale shark\"\n[5] \"bear\"       \n\n\n\nanimals <- factor(animals)\nanimals\n\n\n[1] cat         dog         parrot      whale shark bear       \nLevels: bear cat dog parrot whale shark\n\nNote the new information R gives us, the Levels, which is all possible values we can put into the factor. They are automatically ordered alphabetically on creation. We can also pass a vector of levels on creation.\n\n\nanimals <- c(\"cat\", \"dog\", \"parrot\", \"whale shark\", \"bear\")\nfactor(animals, levels = c(\"parrot\", \"cat\", \"dog\", \"bear\"))\n\n\n[1] cat    dog    parrot <NA>   bear  \nLevels: parrot cat dog bear\n\nA factor can only contain elements that are in the levels, so because I omitted the whale shark, it will be turned into NA. The tidyverse contains the forcats package to help with factors. Most functions from this package start with fct_.\n\n\n\n\n\nFor example, the fct_relevel function, which keeps all levels but let’s us change the order:\n\n\nanimals <- factor(animals)\nfct_relevel(animals, c(\"parrot\", \"dog\"))\n\n\n[1] cat         dog         parrot      whale shark bear       \nLevels: parrot dog bear cat whale shark\n\nUsing this in action, we get:\n\n\nplt <- gapminder %>% \n  mutate(continent = fct_relevel(continent, \"Europe\", \"Oceania\")) %>% \n  ggplot(aes(year, lifeExp, group = country)) +\n  geom_line(alpha = 0.3) +\n  facet_wrap(~ continent)\n\nplt\n\n\n\n\nI saved the plot to a variable called plt because we need it later. Let’s make this plot a bit prettier by adding color! The gapminder package that provided this dataset also included a nice color palette. I included it as a .csv file in the data/ folder so that we can practice importing data once more. But you could also take the shortcut of getting it straight from the package (gapminder::country_colors). Here, we are using the head function to look at the first couple of rows of the tibble and to look at the first couple of elements of the named vector from the package.\n\n\ncountry_colors <- read_csv(\"data/country_colors.csv\")\nhead(country_colors)\n\n\n# A tibble: 6 x 2\n  country          color  \n  <chr>            <chr>  \n1 Nigeria          #7F3B08\n2 Egypt            #833D07\n3 Ethiopia         #873F07\n4 Congo, Dem. Rep. #8B4107\n5 South Africa     #8F4407\n6 Sudan            #934607\n\n\n\nhead(gapminder::country_colors)\n\n\n         Nigeria            Egypt         Ethiopia Congo, Dem. Rep. \n       \"#7F3B08\"        \"#833D07\"        \"#873F07\"        \"#8B4107\" \n    South Africa            Sudan \n       \"#8F4407\"        \"#934607\" \n\nNotice, that the csv that we read in translates to a tibble with two columns, namely country and color. But what we need for ggplot to assign colors to the countries is what the gapminder package provides: a names vector. The names are the countries and the values so called hexadecimal (short Hex) color codes (https://www.w3schools.com/colors/colors_hexadecimal.asp). So what we want to do is translate the tibble into a named vector:\n\n\ncountry_colors <- country_colors %>% \n  mutate(color = set_names(color, country)) %>% \n  pull(color)\n\nhead(country_colors)\n\n\n         Nigeria            Egypt         Ethiopia Congo, Dem. Rep. \n       \"#7F3B08\"        \"#833D07\"        \"#873F07\"        \"#8B4107\" \n    South Africa            Sudan \n       \"#8F4407\"        \"#934607\" \n\nTwo things happened here that are sort of new. set_names is a handy way to take a vector and return a vector with names. It fits better into the tidyverse syntax than the “old” way of assigning to names(x) <- c(\"new\", \"names\", \"vector\"). And secondly pull can be though of as a pipeable dollar. It pulls out the column of a tibble or the element of a named list.\n\n\ngapminder$year %>% head()\n\n\n[1] 1952 1957 1962 1967 1972 1977\n\ngapminder %>% pull(year) %>% head()\n\n\n[1] 1952 1957 1962 1967 1972 1977\n\nNow, with our color vector ready to go, we can make the plot pretty. Remember the variable we saved our plot to? We can add more ggplot functions to it just like to a regular ggplot. A guide is the generalization of a legend, so we are setting it to none because adding a legend for 142 different colors (/countries) would fill the whole plot.\n\n\nplt +\n  aes(color = country) +\n  scale_color_manual(values = country_colors, guide = guide_none()) +\n  theme_minimal() + \n  labs(x = \"\",\n       y = \"Life Expectancy at Birth\",\n       title = \"Life Expectancy over Time\")\n\n\n\n\nWe also added a theme and modified the axis titles. You might have already notice a number of very pronounced dips in some of the lines. We will investigate this rather bleak reality when we talk about modeling and iteration next week.\nExercises\nDrink a cup of coffee or tea, relax, because you just worked through quite a long video.\nFamiliarize yourself with the folders on your computer. Make sure you understand, where your directories and files live.\nFrom RStudio, create a new RStudio project for this course.\nInside the project folder, create a folder for the data.\nCreate a new Rmarkdown document at the top level of your project folder for today’s exercises, again including questions that came up during the course.\nDownload the data for today in one of the ways taught. You can refer to the script anytime.\nMake sure you have all the important settings set and are feeling right at home in RStudio.\n\nThe file ./data/exercise1.txt is in an unfamiliar format.\nFind out how it is structured and read it as a tibble.\nCreate a scatterplot of the x and y column with ggplot2.\nLook at the help page for geom_point. What is the difference between geom_point(aes(color = <something>)) and geom_point(color = <something>)? A relevant hint is in the section about the ...-argument.\nMake the plot pretty by coloring the points, keeping in mind the above distinction.\n\nRead in the gapminder dataset with readr\nUsing a combination of dplyr verbs and / or visualizations with ggplot2, answer the following questions:\nWhich continent had the highest life expectancy on average in the most current year? There are two options here. First, calculate a simple mean for the countries in each continent. Then, remember that the countries have different population sizes, so we really need a weighted mean using R’s function weighted.mean().\nIs there a relationship between the GDP per capita and the life expectancy? A visualization might be helpful.\nHow did the population of the countries change over time? Make the plot more informative by adding color, facets and labels (with geom_text). Can you find out, how to add the country name label only to the last year? Hint: Have a look at the data argument that all geom_-functions have.\n\nResources\nPackage Documentation\nThe tidyverse website\nThe readr package website with cheatsheet\nThe dplyr package website with cheatsheet\nGetting Help\nHow to find help\nR4DS online learning community\n\n\n\n“Artwork by @allison_horst.” 2020. https://github.com/allisonhorst/stats-illustrations.\n\n\nBryan, Jennifer. 2017. Gapminder: Data from Gapminder. Manual.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\n\n\n",
    "preview": "lectures/lecture2/lecture2_files/figure-html5/prev-plt-1.png",
    "last_modified": "2020-11-14T17:05:13+01:00",
    "input_file": "lecture2.utf8.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "lectures/lecture1/",
    "title": "Lecture 1",
    "description": "... in which we get started with R and RStudio,\nexplore the basic structures and operations of R\nand build our first plot by discovering a Grammar\nof Graphics.",
    "author": [
      {
        "name": "Jannik Buhr",
        "url": "https://jmbuhr.de"
      }
    ],
    "date": "2020-11-02",
    "categories": [
      "lecture"
    ],
    "contents": "\n\nContents\nVideo\nSlides\nScript\nWhat You will Learn\nFirst Things First: Installing R\nExecuting R Code\nBuilding Blocks of R\nAtomic Datatypes\nVariables\nFunctions\nVectors\nVectorization\n\nFunctions and Packages – Making our lives easier\nThe Tidyverse\n\nLiterate Programming: Rmarkdown\nOur First Dataset: The Palmer Penguins\nLists and dataframes\n\nTranslating Data into Visualizations\nThe Community: There to catch You.\n\nExercises\nSolutions\nResources\nTidyverse\nRmarkdown\nR in general\nStatistics\nTalks, Podcasts, Blogs, Videos\nMisc\n\n\nVideo\nWatch today’s video here:\n\n\nSlides\nHover over the slides and press f for full screen mode. Press ? for a list of keyboard shortcuts. The arrow keys bring you to the next and previous slide.\n\n\n\n\nScript\nWhat You will Learn\nThroughout your scientific career — and potentially outside of it — you will encounter various forms of data. Maybe you do an experiment and measured the fluorescence of a molecular probe, or you simply count the penguins at your local zoo. Everything is data in some form or another. But raw numbers without context are meaningless and tables of numbers are not only boring to look at, but often hide the actual structure in the data.\nIn this course you will learn to handle different kinds of data. You will learn to create pretty and insightful visualizations, compute different statistics on your data and also what these statistical concepts mean. From penguins to p-values, I got you covered.\nThe course will be held in English, as the concepts covered will directly transfer to the research you do, where the working language is English. That being said, feel free to ask questions in any language that I understand, so German is also fine. My Latin is a little rusty, thought.\nIn this course, we will be using the programming language R. R is a language particularly well suited for data analysis, because it was initially designed by statisticians and because of the interactive nature of the language, which makes it easier to get started. So don’t fret if this is your first encounter with programming, we will take one step at a time.\nThe datasets chosen to illustrate the various concepts and tools are not particularly centered around Biology. Rather, I chose general datasets that require less introduction and enable us to focus on learning R and statistics. This is why we will be talking about penguins, racing games or life expectancy instead of intricate molecular measurements.\nFirst Things First: Installing R\n\n\n\n\n\nBut I was getting ahead of myself. First, we need to install R. You can download the installer for your operating system here: https://cran.r-project.org/. Feel free to post a question if you get stuck. This already gives you the ability to execute R code or use the interactive R console, but it is way more comfortable to use R inside of a so called IDE (Integrated Development Environment). IDEs give you neat things like autocompletion, a window for your plots and a help panel. The main IDE for R is called RStudio. We will be using it for this course and you can download it here: https://www.rstudio.com/products/rstudio/download/#download\n\n\n\nExecuting R Code\nYou can now execute commands in the R console in the bottom left. For example we can calculate a mathematical expression:\n\n\n1 + 1\n\n\n[1] 2\n\nOr generate the numbers from one to 10:\n\n\n1:10\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nBut I rarely type directly into the console. Because we want our results to be reproducible, we write our code in a script first, so that the next person1 can see what we did and replicate our analysis. You will see that reproducibility is quite near and dear to me, so it will pop up once or twice. And as scientists, I am sure you understand the importance.\nTo create a new script, click the little button in the top left corner. In a script you can type regular R code, but it won’t get executed straight away. To send a line of code to the console to be executed, hit Ctrl+Enter. Go ahead, try it with:\n\n\npaste(\"Hello\", \"World!\")\n\n\n[1] \"Hello World!\"\n\nThe paste function combines text, just like + combines numbers. Your code can have comments to tell your future self why you wrote a piece of code the way you did. Any line starting with the number symbol # will be ignored by R.\n\n\n# This line will be ignored\n43 - 1 # as will be the part after this #, but not before it\n\n\n[1] 42\n\nBuilding Blocks of R\nNow it is time to introduce you to the fundamental datatypes of R. We are going to cover the so called atomic datatypes first and introduce others as they appear.\nAtomic Datatypes\nFirst we have numbers (which internally are called numeric or double)\n\n\n12\n12.5\n\n\n\nThen, there are whole numbers (integer)\n\n\n1L # denoted by L\n\n\n\nas well as the rarely used complex numbers (complex)\n\n\n1 + 3i # denoted by the small i for the imaginary part\n\n\n\nText data however will be used more often (character, string). Everything enclosed in quotation marks will be treated as text. Double or single quotation marks are both fine.\n\n\n\"It was night again.\"\n'This is also text'\n\n\n\nLogical values can only contain yes or no, or rather TRUE and FALSE in programming terms (boolean, logical).\n\n\nTRUE\nFALSE\n\n\n\nThere are some special types that mix with any other type. Like NULL for no value and NA for Not Assigned.\n\n\nNULL\nNA\n\n\n\nNA is contagious. Any computation involving NA will return NA (because R has no way of knowing the answer):\n\n\nNA + 1\n\n\n[1] NA\n\nmax(NA, 12, 1)\n\n\n[1] NA\n\nBut some functions can remove NAs before giving us an answer:\n\n\nmax(NA, 12, 1, na.rm = TRUE)\n\n\n[1] 12\n\nYou can ask for the datatype of an object with the function typeof:\n\n\ntypeof(\"hello\")\n\n\n[1] \"character\"\n\nThere is also a concept called factors (factor) for categorical data, but we will talk about that later, when we get deeper into vectors.\nVariables\nOften, you will want to store the result of a computation for reuse, or to give it a sensible name and make your code more readable. This is what variables are for. We can assign a value to a variable using the assignment operator <- (In RStudio, there is a shortcut for it: Alt+Minus):\n\n\nmy_number <- 42\n\n\n\nExecuting the above code will not give you any output, but when you use the name of the variable, you can see its content.\n\n\nmy_number\n\n\n[1] 42\n\nAnd you can do operations with those variables:\n\n\nx <- 41\ny <- 1\nx + y\n\n\n[1] 42\n\n\nNOTE Be careful about the order of execution! R enables you to work interactively and to execute the code you write in your script in any order with Ctrl+Enter, but when you execute (=“source”) the whole script, it will be executed from top to bottom.\n\nFurthermore, code is not executed again automatically, if you change some dependency of the expression later on. So the second assignment to x doesn’t change y.\n\n\nx <- 1\ny <- x + 1\nx <- 1000\ny\n\n\n[1] 2\n\nVariable names can contain letters (capitalization matters), numbers (but not as the first character) and underscores _.2\n\n\n# snake_case\nmain_character_name <- \"Kvothe\"\n\n# or camelCase\nbookTitle <- \"The Name of the Wind\"\n\n# you can have numbers in the name\nx1 <- 12\n\n\n\nA depiction of various naming styles (“Artwork by @allison_horst” 2020).Functions\n\nIn R, everything that exists is an object, everything that does something is a function.\n\nFunctions are the main workhorse of our data analysis. For example, there are mathematical functions, like sin, cos etc.\n\n\nsin(x = 0)\n\n\n[1] 0\n\nFunctions take arguments (sometimes called parameters) and sometimes they also return things. The sin function takes just one argument x and returns its sine. What we do with the returned value is up to us. We can use it directly in another computation or store it in a variable. If we don’t do anything with the return value, R simply prints it to the console.\nNote, that the = inside the function parenthesis gives x = 0 to the function and is separate from any x defined outside of the function. For example:\n\n\nx <- 10\ncos(x = 0)\n\n\n[1] 1\n\n# x outside of the function is still 10\nx\n\n\n[1] 10\n\nTo learn more about a function in R, execute ? with the function name or press F1 with your mouse over the function. This is actually one of the most important things to learn today, because the help pages can be… well… incredibly helpful.\n\n\n?sin\n\n\n\nWe can pass arguments by name or by order of appearance. The following two expressions are equivalent.\n\n\nsin(x = 12)\nsin(12)\n\n\n\nVectors\nA vector is an ordered collection of things which have the same datatype, where a datatype is something like numbers (numeric), text (character also called string) or whole numbers (integer).\nThe basic datatypes in R are all vectors, which means they can contain more than one entry. You can create a vector by combining things of the same data type with the function c for combine.\n\n\nx <- c(1, 2, 3, 4, 5, 6)\nx\n\n\n[1] 1 2 3 4 5 6\n\nAny atomic datatype mentioned above can be in a vector, but atomic vectors can only store data of the same type. For example, you can have a character vector\n\n\nc(\"This\", \"is\", \"a\", \"character\", \"vector\")\n\n\n[1] \"This\"      \"is\"        \"a\"         \"character\" \"vector\"   \n\nor a vector of logical values\n\n\nc(TRUE, FALSE, TRUE, TRUE)\n\n\n[1]  TRUE FALSE  TRUE  TRUE\n\nBut not a vector with, say text and numbers. If we try to combine data of a different type, R will force all the data into the more permissive type. Because all Numbers can easily be converted into text, but not all text can be converted to numbers, this makes everything text in this example:\n\n\nc(\"Some text\", 42, 12)\n\n\n[1] \"Some text\" \"42\"        \"12\"       \n\nNote the quotation marks around the numbers, marking them as text. If we were to try and use them as numbers, we would get and error message:\n\n\n\"12\" + 1\n\n\nError in \"12\" + 1: non-numeric argument to binary operator\n\nThere are other cases where we will encounter error messages. Programming languages are not unlike human languages. The computer will not always understand, what you want it to do, unless you use exactly the right grammar and vocabulary. An error messages is R’s way of telling us, that it didn’t understand, or that we asked it to do something impossible. Even experienced programmers are very fond of this advice:\n\n\n\nFigure 1: Maybe the most important programming advice.\n\n\n\nTo solve above error message, we need to explicitly tell R to convert the text to a number:\n\n\nas.numeric(\"12\") + 1\n\n\n[1] 13\n\nSubsetting\nWe can look at, or change, subsets of vectors using square brackets [] like so:\n\n\nmy_elements <- c(\"first\", \"second\", \"third\")\nmy_elements[2]\n\n\n[1] \"second\"\n\n\n\nmy_elements[3] <- \"new element\"\nmy_elements\n\n\n[1] \"first\"       \"second\"      \"new element\"\n\nIf we assign names to the elements, we can also reference them by name.\n\n\nnames(my_elements) <- c(\"e1\", \"e2\", \"e3\")\nmy_elements\n\n\n           e1            e2            e3 \n      \"first\"      \"second\" \"new element\" \n\n\n\nmy_elements[\"e3\"]\n\n\n           e3 \n\"new element\" \n\nPass a vector of indices (or names) to the square brackets to get (or set) multiple elements:\n\n\nmy_elements[c(1, 3)]\n\n\n           e1            e3 \n      \"first\" \"new element\" \n\nUsing a logical vector yields all elements where the vector is TRUE:\n\n\nmy_elements[c(TRUE, TRUE, FALSE)]\n\n\n      e1       e2 \n \"first\" \"second\" \n\nVectorization\nThe basic mathematical operations in R and a lot of functions are vectorized. This means, they operate on every element of the vector. Here, every element is multiplied by 2 and the result is printed to the console.\n\n\nx * 2\n\n\n[1]  2  4  6  8 10 12\n\nThe original vector x was not changed in doing so.\n\n\nx\n\n\n[1] 1 2 3 4 5 6\n\nBut we could have, by assigning the result back to x, thus overwriting its previous content. The right hand side (RHS) is executed first:\n\n\nx <- x * 2\n\n\n\nNow x changed:\n\n\nx\n\n\n[1]  2  4  6  8 10 12\n\nA handy way of creating vectors of numbers is with the : operator to specify a range of values:\n\n\n1:5\n\n\n[1] 1 2 3 4 5\n\nOr using the seq function with some additional (optional) parameters:\n\n\nseq(from = 1, to = 10)\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNow you: Look at the documentation/help page for seq and find out how to create a vector of all even numbers from 2 to 100.\n\nFunctions and Packages – Making our lives easier\nYou just learned about the functions sin, seq and max. But wait, there is more! Not only in the sense that there are more functions in R (what kind of language would that be with only two verbs?!), but also in a more powerful way:\n\nWe can define our own functions!\n\nThe syntax (\\(\\leftarrow\\) grammar for programming languages) is as follows.\n\n\nname_for_the_function <- function(parameter1, parameter2, ...) { # etc.\n  # body of the function\n  # things happen\n  result <- parameter1 + parameter2\n  # Something the function should return to the caller\n  return(result)\n}\n\n\n\nThe function ends when it reaches the return keyword. It also ends when it reaches the end of the function body and implicitly returns the last expression. So we could have written it a bit shorter and in fact you will often see people omitting the explicit return at the end:\n\n\nadd <- function(x, y) {\n  x + y\n}\n\n\n\nAnd we can call our freshly defined function:\n\n\nadd(23, 19)\n\n\n[1] 42\n\nGot an error like Error in add(23, 19) : could not find function \"add\"? Check that you did in fact execute the code that defines the function (i.e. put your cursor on the line with the function keyword and hit Ctrl+Enter.).\n\nNow you: Define a function that takes one argument, a vector of numbers, devides each element by the length of the vector (hint: length is the function to get the length) and returns the resulting scaled vector.\n\nYou are not the only one using R. There is a welcoming and helpful community out there. Some people also write a bunch of functions and put them together in a so called package. And some people even went a step further. The tidyverse is a collection of packages that play very well together and also iron out some of the quirkier ways in which R works (Wickham et al. 2019). They provide a consistent interface to enable us to do more while having to learn less special cases. The R function install.packages(\"<package_name_here>\") installs packages from CRAN a curated set of R packages.\nThe Tidyverse\nGo ahead and install the tidyverse packages with\n\n\ninstall.packages(\"tidyverse\")\n\n\n\nThis is one exception to our effort of having everything in our script and not just in the console. We don’t want R trying to install the package every time we run the script, as this needs to happen only once. So you can either turn it into a comment, delete it from the script, or only type it in the console. You can also use RStudio’s built-in panel for package installation.\n\n\n\nTo make the functions from a package available to your R session, run the library function with the name of the package.\n\n\nlibrary(tidyverse)\n\n\n\nThe convention is, to keep all library-calls at the top of your script, so that you ,and others, can see straight away, which packages are needed. Don’t worry about the messages that pop up. This is just the tidyverse telling us that two of it’s functions (lag and filter) have functions with the same names in another package (or in this case base-R) and because we loaded the tidyverse second, R will now use the tidyverse functions. This is what “masking” means.\nLiterate Programming: Rmarkdown\n\n\n\n(“Artwork by @allison_horst” 2020)There is another package I would like you to install. It is called Rmarkdown.\n\n\ninstall.packages(\"rmarkdown\")\n\n\n\nRmarkdown enables us, to combine text with code and then produce a range of output formats like pdf, html, word documents, presentations etc. In fact, this whole website, including the slides, was created with Rmarkdown. Sounds exciting? Let’s dive into it!\nOpen up a new Rmarkdown document with the file extension .Rmd from the New File menu in the top left corner of RStudio: File → New File → R Markdown and choose html as the output format. I particularly like html, because you don’t have to worry about page breaks and it easily works on screens of different sizes, like your phone.\nAn Rmarkdown document consists of three things:\nMetadata:\nInformation about your document such as the author or the date in a format called YAML. This YAML header starts and ends with three minus signs ---.\nText:\nRegular text is interpreted as markdown, meaning it supports things like creating headings by prefixing a line with #, or text that will be bold in the output by surrounding it with **.\nCode chunks:\nStarting with ```{r} and ending with ``` (backticks). They will be interpreted as R code. This is where you write the code like you did in the .R script file. You can insert new chunks with the button on the top right of the editor window or use the shortcut Ctrl+Alt+i.\nUse these to document your thoughts alongside your code when you are doing data analysis. Future you (and reviewer number 2) will be happy! To run code inside of chunks, use,the little play button on the chunk, the tried and true Ctrl+Enter to run one line, or Ctrl+Shift+Enter to run the whole chunk. Your chunks can be as large or small as you want, but try to maintain some sensible structure.\nOur First Dataset: The Palmer Penguins\n(“Artwork by @allison_horst” 2020)So let’s explore our first dataset together in a fresh Rmarkdown document. The setup chunk is special. It gets executed automatically before any other chunk in the document is run. This makes it a good place to load packages. The dataset we are working with today actually comes in its own package, so we need to install this as well (Yes, there is a lot of installing today, but you will have to do this only once):\n\n\ninstall.packages(\"palmerpenguins\")\n\n\n\nAnd then we populate our setup chunk with\n\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n\n\nThis gives us the penguins dataset (Horst, Hill, and Gorman 2020):\n\n\npenguins\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\nLet’s talk about the shape of the penguins object. The str function reveals the structure of an object to us.\n\n\nstr(penguins)\n\n\ntibble [344 × 8] (S3: tbl_df/tbl/data.frame)\n $ species          : Factor w/ 3 levels \"Adelie\",\"Chinstrap\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ island           : Factor w/ 3 levels \"Biscoe\",\"Dream\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ bill_length_mm   : num [1:344] 39.1 39.5 40.3 NA 36.7 39.3 38.9 39.2 34.1 42 ...\n $ bill_depth_mm    : num [1:344] 18.7 17.4 18 NA 19.3 20.6 17.8 19.6 18.1 20.2 ...\n $ flipper_length_mm: int [1:344] 181 186 195 NA 193 190 181 195 193 190 ...\n $ body_mass_g      : int [1:344] 3750 3800 3250 NA 3450 3650 3625 4675 3475 4250 ...\n $ sex              : Factor w/ 2 levels \"female\",\"male\": 2 1 1 NA 1 2 1 2 NA NA ...\n $ year             : int [1:344] 2007 2007 2007 2007 2007 2007 2007 2007 2007 2007 ...\n\nLists and dataframes\nPreviously, we only had atomic vectors, where all elements are of the same type, like a vector of numbers, and the individual elements could not contain other things themselves (hence the name atomic): c(1, 2, 3). The next more general thing is a list, which we can create with the function list(...). Lists can contain arbitrary elements, even other lists:\n\n\nmy_list <- list(1, \"hello\", c(1, 2, 3), list(42, \"text\"))\nmy_list\n\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[1] 1 2 3\n\n[[4]]\n[[4]][[1]]\n[1] 42\n\n[[4]][[2]]\n[1] \"text\"\n\nThe print output suggests something else: For vectors, we could subset them using [], but here we will need double square brackets [[]].\n\n\nmy_list[[3]]\n\n\n[1] 1 2 3\n\nUsing single brackets would just give us a subset of the list, not the actual element of the list (yes, this can be confusing):\n\n\nmy_list[3]\n\n\n[[1]]\n[1] 1 2 3\n\nThe penguins variable contains what is called a data.frame. The reason I talked about lists just now is that dataframes are built on top of lists, where the elements are the columns. Because dataframes form this rectangular data format like a spreadsheet you know from excel, the constraint is that the elements of the list need to have the same length. We can demonstrate this by creating our own dataframe from a list.\n\n\nnew_list <- list(x = 1:3, y = c(10, 42, 3), third = c(\"hello\", \"from\", \"R\"))\nnew_list\n\n\n$x\n[1] 1 2 3\n\n$y\n[1] 10 42  3\n\n$third\n[1] \"hello\" \"from\"  \"R\"    \n\nNotice that I did another thing: I gave names to the elements of the list. This is nice because of two reasons. Firstly, as the print output already suggests, we can now use the dollar syntax $ to refer to the individual elements by name instead of by position and RStudio’s autocomplete helps us out.\n\n\nnew_list$x\n\n\n[1] 1 2 3\n\nSecondly, the names will become column names when we turn it into a dataframe:\n\n\nmy_first_df <- as.data.frame(new_list)\nmy_first_df\n\n\n  x  y third\n1 1 10 hello\n2 2 42  from\n3 3  3     R\n\nThere is one last difference for the penguins. They are also a tibble, which is again built on top of dataframes and makes the object look nicer when we print it to the console. Compare the following when executing them in the console:\n\n\npenguins\nas.data.frame(penguins)\n\n\n\nThe dataset contains data for 344 penguins. of 3 different species, collected from 3 islands in the Palmer Archipelago, Antarctica3.\nTranslating Data into Visualizations\nYou probably took this course because you want to build some cool visualizations for you data. In order to do that, let us talk about how we can describe visualizations. Just like language has grammar, some smart people came up with a grammar of graphics (Wilkinson et al. 2005), which was then slightly modified and turned into an R package so that we can not only talk about but also create visualizations using this grammar (Wickham 2010).\n\n\n\n\n\nThe package is called ggplot2 and we already have it loaded because it is included in the tidyverse. Before looking at the code, we can describe what we need in order to create this graphic.\n\n\n\nggplot(penguins, aes(flipper_length_mm, bill_length_mm,\n                     color = species,\n                     shape = sex)) +\n  geom_point(size = 2.5) +\n  labs(x = \"Flipper length [mm]\",\n       y = \"Bill length [mm]\",\n       title = \"Penguins!\",\n       subtitle = \"The 3 penguin species can differentiated by their flipper and bill lengths\") +\n  theme_minimal() +\n  scale_color_brewer(type = \"qual\")\n\n\n\n\nWe can build this plot up step by step. The data is the foundation of our plot, but this just gives us an empty plotting canvas. I am assigning the individual steps we are going through to a variable, so that we can sequentially add elements, but you can do this in one step as shown above.\n\n\nplt <- ggplot(penguins)\nplt\n\n\n\n\nThen, we add and aesthetic mapping to the plot. It creates a relation from the features of our dataset (like the flipper length of each penguin) to a visual property, like position of the x-axis, color or shape.\n\n\nplt <- ggplot(penguins,\n              aes(x = flipper_length_mm,\n                  y = bill_length_mm,\n                  color = species,\n                  shape = sex))\nplt\n\n\n\n\nStill, the plot is empty, it only has a coordinate system with a certain scale. This is because we have no geometric objects to represent our aesthetics. Elements of the plot are added using the + operator and all geometric elements that ggplot knows start with geom_. Let’s add some points:\n\n\nplt <- plt +\n  geom_point()\nplt\n\n\n\n\nLook at the help page for geom_point to find out what aesthetics it understands. The exact way that features are mapped to aesthetics is regulated by scales starting with scale_ and the name of an aesthetic:\n\n\nplt <- plt +\n  scale_color_brewer(type = \"qual\")\nplt\n\n\n\n\nWe can add or change labels (like the x-axis-label) by adding the labs function.\n\n\nplt <- plt +\n    labs(x = \"Flipper length [mm]\",\n         y = \"Bill length [mm]\",\n         title = \"Penguins!\",\n         subtitle = \"The 3 penguin species can differentiated by their flipper and bill lengths\")\n\n\n\nThe overall look of the plot is regulated by themes like the premade theme_ functions or more finely regulated with the theme() function, which uses element functions to create the look of individual elements. Autocomplete helps us out a lot here (Ctrl+Space).\n\n\nplt <- plt + \n  theme_minimal() +\n  theme(legend.text = element_text(face = \"bold\"))\nplt\n\n\n\n\nThe Community: There to catch You.\n\nCoding can be incredibly rewarding, but also incredibly frustrating.\n\nLuckily, the R community is with you!\n(“Artwork by @allison_horst” 2020)In the video I give a brief overview of the resources linked below. Come back here anytime as a reference.\nExercises\nThis course is not graded, but I need some way of confirming that you did indeed take part in this course. In order to get the confirmation, you will send your solutions for a minimum of 5 out of the 8 exercises to me before the Friday following the lecture upload on Monday. For each week I would like you to create a fresh Rmarkdown document with your solutions as code as well as any questions that arose during the lecture. This will help me a lot in improving this course.\nWhen you are done solving the exercises, hit the knit button (at the top of the editor panel) and send me the resulting html document via discord or email (confirm that it looks the way you expected beforehand).\nHere are today’s tasks:\nWrite a section of text about your previous experience with data analysis and/or programming (optional, but I can use this information to customize the course).\nWrite the code that loads in the tidyverse and the palmer penguins data set.\nProduce a scatterplot (meaning a plot with points) of the bill length vs. the bill depth, colorcoded by species.\nImaginary bonus points if you manage to use the same colors as in the image above (hint: look at the help page for scale_color_manual() to find out how). Even more bonus points if you also look into the theme() function and it’s arguments, or the theme_<...>() functions to make the plot prettier.\n\nCreate a vector of all odd numbers from 1 to 99 and store it in a variable.\nCreate a second variable that contains the squares of the first.\nStore both variables in a named list and then turn this list into a tibble (the enhanced version of a data.frame\nDiscover a shortcut for the three steps above using the function tibble. Specifically, have a look at the third bullet point in the description of ?tibble::tibble (The two colons :: specify the package a function is coming from. You only need tibble(...) in the code because the tibble package is loaded automatically with the tidyverse. Here, I specify it directly to send you to the correct help page).\nCreate a scatterplot of the two variables stored in the tibble using ggplot.\nWhat geom_ function do you need to add to the plot to add a line that connects your points?\n\nCheck the metadata (YAML) of your Rmarkdown document and make sure it contains your name as the author: .\nHere are a couple more YAML options you can try if you feel adventurous.\n\nSolutions\nThe Office Hour for the solutions and questions is on Friday, Nov 6, 2020 at 10:00. Find the link in the discord.\nResources\nTidyverse\nR for Data Science (Wickham and Grolemund 2017)\nR4DS online Community\nRStudio Cheat Sheets!\nThe Modern Dive (Kim 2019)\nRStudio Education\nRmarkdown\nhttps://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf\nhttps://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf\nhttps://bookdown.org/yihui/rmarkdown-cookbook/\nhttps://bookdown.org/yihui/rmarkdown/\nhttps://pandoc.org/MANUAL.html#pandocs-markdown\nhttps://reproducible-analysis-workshop.readthedocs.io/en/latest/6.RMarkdown-knitr.html\nhttps://rmarkdown.rstudio.com/index.html\nR in general\nAdvanced R (Wickham 2019)\nHands on Programming with R (Grolemund and Wickham 2014)\nR Packages (Wickham 2015)\nData Visualization: A Practical Introduction (Healy 2018)\nGraph Cookbook (Chang 2013)\nStatistics\nIntuitive Biostatistics (Motulsky 2017)\nStatistics Done Wrong (Reinhart 2015)\nTalks, Podcasts, Blogs, Videos\nDavid Robinson\nYouTube\nwebsite\n\nJulia Silge\nYouTube\nwebsite\n\nAlison Hill\nwebsite\n\nMisc\nCute and insightful illustrations (“Artwork by @allison_horst” 2020)\nHappy Git with R\nMade with the help of these amazing packages (plus documentation): (R Core Team 2020); (Xie 2020a); (Allaire et al. 2020); (Xie 2015); (Xie 2020b).\n\n\n\nAllaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for r. Manual.\n\n\n“Artwork by @allison_horst.” 2020. https://github.com/allisonhorst/stats-illustrations.\n\n\nChang, Winston. 2013. R Graphics Cookbook: Practical Recipes for Visualizing Data. 1 edition. Beijing Cambridge Farnham Köln Sebastopol Tokyo: O’Reilly Media.\n\n\nGrolemund, Garrett, and Hadley Wickham. 2014. Hands-On Programming with R: Write Your Own Functions and Simulations. Sebastopol, CA: O’Reilly Media.\n\n\nHealy, Kieran. 2018. Data Visualization: A Practical Introduction. 1 edition. Princeton, NJ: Princeton University Press.\n\n\nHorst, Allison, Alison Hill, and Kristen Gorman. 2020. Palmerpenguins: Palmer Archipelago (antarctica) Penguin Data. Manual.\n\n\nKim, Chester Ismay and Albert Y. 2019. Statistical Inference via Data Science. CRC Press.\n\n\nMotulsky, Harvey. 2017. Intuitive Biostatistics: A Nonmathematical Guide to Statistical Thinking. 4 edition. New York: Oxford University Press.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Manual. Vienna, Austria: R Foundation for Statistical Computing.\n\n\nReinhart, Alex. 2015. Statistics Done Wrong: The Woefully Complete Guide. 1 edition. San Francisco: No Starch Press.\n\n\nWickham, Hadley. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. https://doi.org/10.1198/jcgs.2009.07098.\n\n\n———. 2015. R Packages: Organize, Test, Document, and Share Your Code. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\n———. 2019. Advanced R, Second Edition. 2 edition. Boca Raton: Chapman and Hall/CRC.\n\n\nWickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 1 edition. Sebastopol, CA: O’Reilly Media.\n\n\nWilkinson, Leland, D. Wills, D. Rope, A. Norton, and R. Dubbs. 2005. The Grammar of Graphics. 2nd edition. New York: Springer.\n\n\nXie, Yihui. 2015. Dynamic Documents with R and Knitr. Second. Boca Raton, Florida: Chapman and Hall/CRC.\n\n\n———. 2020a. Knitr: A General-Purpose Package for Dynamic Report Generation in r. Manual.\n\n\n———. 2020b. Xaringan: Presentation Ninja. Manual.\n\n\nThis will most likely be future You. And you will thank yourself later↩︎\nThey can also contain dots (.), but it is considered bad practice because it can lead to some confusing edge cases.↩︎\nhttps://allisonhorst.github.io/palmerpenguins/↩︎\n",
    "preview": "lectures/lecture1/lecture1_files/figure-html5/final-penguin-plot-1.png",
    "last_modified": "2020-11-01T23:17:45+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  }
]
