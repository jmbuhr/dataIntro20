---
title: "lecture notes 6"
author: "Jannik"
date: "12/6/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE
)
```

```{r}
library(tidyverse)
library(tidymodels)

theme_set(theme_light())
```

# Script

## Some Preparation


### Sidenote on Reproducible Environments with `renv`









## All models are wrong, but some are useful








### Types of Models








## Say Hello to Spotify Data

```{r}
songs <- read_csv("data/spotify_playlist.csv")
glimpse(songs)
```




## Visualising Continuous Distributions


```{r}
head(songs$valence)
```

```{r}
songs %>% 
  ggplot(aes(x = factor(0), valence)) +
  geom_jitter(width = 0.05)
```

```{r}
songs %>% 
  ggplot(aes(valence)) +
  geom_histogram()
```


```{r}
songs %>% 
  ggplot(aes(valence)) +
  geom_density(fill = "darkblue", alpha = 0.3)
```



```{r}
songs %>% 
  ggplot(aes(x = factor(mode), valence)) +
  geom_violin(fill = "darkblue", alpha = 0.3) +
  ggbeeswarm::geom_quasirandom(alpha = 0.5)
```


### Summary Statistics...

```{r}
songs %>% 
  group_by(mode) %>% 
  summarise(
    max = max(valence),
    min = min(valence)
  )

range(songs$valence)
```

```{r}
songs %>% 
  group_by(mode) %>% 
  summarise(
    mean = mean(valence),
    median = median(valence)
  )
```

```{r}
songs %>% 
  add_row(mode = 1, valence = 1.2) %>% 
  ggplot(aes(factor(mode), valence)) +
  geom_boxplot(fill = "darkblue",
               alpha = 0.3,
               outlier.alpha = 1) +
  annotate(geom = "curve", x = 1.8, y = 1.25, xend = 1.95, yend = 1.19,
           curvature = .3, arrow = arrow(length = unit(2, "mm"))) +
  annotate("text", x = 1.75, y = 1.25,
           label = "outlier\n (that I added because there where none)",
           vjust = 0.5, hjust = 1) +
  coord_cartesian(clip = "off")
```

```{r}
songs %>%   
  add_row(mode = 1, valence = 1.2) %>% 
  ggplot(aes(factor(mode), valence)) +
  geom_boxplot(outlier.colour = NA) +
  ggbeeswarm::geom_quasirandom()
```

```{r}
sem <- function(x) sd(x)/lenght(x)
```





### ... or: How to Lie with Graphs


```{r}
songs %>% 
  ggplot(aes(speechiness, color = factor(mode),
             fill = factor(mode))) +
  geom_density(alpha = 0.3)
```




## Graphic Devices, Fonts and the ggplot Book









### ggplot book









### Graphics Devics









## The Normal Distribution and the Central Limit Theorem


```{r}
tibble(x = seq(-3, 3, 0.01)) %>% 
  ggplot(aes(x)) +
  geom_function(fun = dnorm) +
  stat_function(geom = "area", fun = dnorm,
                fill = "darkblue", alpha = 0.3) +
  labs(y = "density", title = "Normal Distribution Density")
```

```{r}
tibble(x = seq(-3, 3, 0.01)) %>% 
  ggplot(aes(x)) +
  geom_function(fun = pnorm) +
  labs(y = "probability", title = "Cummulative Probability")
```

The Central Limit Theorem (CLT) states
that the sample mean of a sufficiently large number
of independent random variables is approximately normally distributed.
The larger the sample, the better the approximation.

```{r}
valence <- songs %>% filter(mode == 1) %>% pull(valence)
qqnorm(valence)
qqline(valence)
```



### Log-normality









## The T-Distribution










## Student's T-Test

```{r}
songs %>% 
  ggplot(aes(x = factor(mode), valence)) +
  geom_violin(fill = "darkblue", alpha = 0.3) +
  ggbeeswarm::geom_quasirandom(alpha = 0.5)
```

```{r}
t.test(valence ~ mode, data = songs)
```



## Wilcoxon rank-sum test


```{r}
wilcox.test(speechiness ~ mode, data = songs)
```

```{r}
speechiness_minor <- songs %>% filter(mode == 0) %>% pull(speechiness)
speechiness_major <- songs %>% filter(mode == 1) %>% pull(speechiness)

test <- wilcox.test(speechiness_minor, speechiness_major)
test$p.value
```

```{r}

```




### Direction of Testing










### Confidence Intervals



```{r}
valence_minor <- songs %>% filter(mode == 0) %>% pull(valence)

test <- t.test(valence_minor)
test$conf.int
```






## Chrunching Dimensions with Dimensionality Reduction: PCA

```{r}
songs %>% 
  ggplot(aes(energy, loudness)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```



```{r}
library(tidymodels)
```

```{r}
songs_rec <- recipe( ~ ., data = songs) %>% 
  update_role(track_name, track_artists, new_role = "id") %>% 
  step_normalize(all_predictors()) %>% 
  step_pca(all_predictors())

```

```{r}
songs_prep <- prep(songs_rec)
songs_prep
```

```{r}
songs_compontents <- tidy(songs_prep, 2)
songs_compontents
```


```{r}
songs_compontents %>% 
  mutate(terms = tidytext::reorder_within(terms, by = value, within = component)) %>% 
  filter(component %in% paste0("PC", 1:3)) %>% 
  ggplot(aes(value, terms, fill = value > 0)) +
  geom_col() +
  facet_wrap(~ component, scales = "free") +
  ggthemes::scale_fill_colorblind() +
  guides(fill = "none") +
  tidytext::scale_y_reordered()
```


```{r}
songs_baked <- bake(songs_prep, new_data = NULL)
songs_baked
```

```{r}
plt <- songs_baked %>% 
  mutate(song = paste(track_name, ",", track_artists)) %>%  
  ggplot(aes(PC1, PC2, label = song)) +
  geom_hline(yintercept = 0, alpha = 0.3) + 
  geom_vline(xintercept = 0, alpha = 0.3) + 
  geom_point()

plotly::ggplotly(plt)
```


```{r}
sdev <- songs_prep$steps[[2]]$res$sdev
percent_variation <- sdev^2 / sum(sdev)

tibble(
  component = paste("PC", 1:15),
  percent_var = percent_variation
) %>% 
  mutate(component = fct_inorder(component)) %>% 
  ggplot(aes(component, percent_var)) +
  geom_col()
```


# Exercises









